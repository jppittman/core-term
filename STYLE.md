# myterm Style Guide

This document outlines the coding style conventions for the `myterm` project. Consistency helps maintain readability and ease of collaboration.

## Comments

The primary goal is code clarity. Comments should supplement clear code structure, not replace it.

1.  **Clarity Over Comments:** Prioritize clear variable/function names, type definitions, constants, and enums over explanatory comments. If the code is hard to understand without a comment, consider refactoring the code first.
2.  **Rustdoc for Public APIs:** Use Rustdoc (`///`) comments to document all public functions, structs, enums, traits, and modules. Explain *what* the item does, its parameters, return values, and any potential panics or important usage notes.
3.  **Non-Obvious Code is a Smell:** If a comment is required to explain a complex or non-obvious piece of logic, treat it as a signal that the underlying code might be too complex and could benefit from simplification or refactoring.

### Comments and LLMs

These points are particularly relevant when working with or generating code using Large Language Models.

1.  **Avoid Obvious Comments:** Do not add comments that merely restate what the code clearly shows (e.g., `// increment i` for `i += 1;`). They add noise and are particularly unhelpful when generated by or reviewed with LLMs.
2.  **No Commit Messages in Comments:** Do not use comments for version control information (e.g., `// Updated to include xyz`). Use Git commit messages for history and rationale. Leaving large blocks of old code commented out is also discouraged; use version control. Commented-out code is only acceptable for *brief*, *clear*, *working* examples of alternative usage immediately adjacent to the code it relates to.

## Code Structure

1.  **Avoid Deep Nesting:** Prefer guard clauses and early returns to deeply nested `if`/`else` or `match` blocks. Aim for a flatter control flow where possible. (Think Go's `if err != nil { return err }` style).

    * **Bad:**
        ```rust
        fn process_item(item: Option<Item>) {
            if let Some(i) = item {
                if i.is_valid() {
                    if i.needs_processing() {
                        // ... deep logic ...
                    } else {
                        // ...
                    }
                } else {
                    // ...
                }
            } else {
                // ...
            }
        }
        ```
    * **Good:**
        ```rust
        fn process_item(item: Option<Item>) {
            let Some(i) = item else {
                // Handle missing item
                return;
            };

            if !i.is_valid() {
                // Handle invalid item
                return;
            }

            if !i.needs_processing() {
                // Handle item not needing processing
                return;
            }

            // ... logic for valid, processable item ...
        }
        ```

2.  **Prefer `match` over `else if`:** When choosing between complex `if`/`else if`/`else` chains and a `match` statement, prefer `match`, especially when dealing with enums or a fixed set of conditions.

## Functions and APIs

1.  **Argument Management (Count & Grouping):** Functions should generally take fewer than 4 arguments. More arguments often indicate a function is trying to do too much or that arguments could be better organized. Group multiple related arguments into a single struct to improve clarity, reduce the argument count, and make function signatures more manageable, especially if the same group of arguments is passed to multiple functions.

    * **Bad (Too many arguments):**
        ```rust
        fn draw_rectangle(x: u32, y: u32, width: u32, height: u32, color: Color, filled: bool) {
            // ...
        }
        ```
    * **Good (Arguments grouped):**
        ```rust
        struct Point { x: u32, y: u32 }
        struct Size { width: u32, height: u32 }
        struct DrawParams { color: Color, filled: bool }

        fn draw_rectangle(top_left: Point, size: Size, params: DrawParams) { // Only 3 arguments now
            // ...
        }
        ```

2.  **Argument Design:** Multiple *unrelated* arguments in a function often indicate a poor design where the function might have too many responsibilities. Consider breaking such functions down.

3.  **Boolean Arguments:** Avoid functions that take boolean arguments. They make the call site unclear (e.g., `process_data(true)` vs `process_data(ProcessMode::Force)`). Prefer using enums or splitting the function into two separate functions (e.g., `process_data_forcefully()` and `process_data_normally()`).

    * **Bad:**
        ```rust
        fn set_option(name: &str, value: &str, persistent: bool) {
            // ... logic based on persistent flag ...
        }
        // Call site: set_option("theme", "dark", true); // What does true mean?
        ```
    * **Good (Enum):**
        ```rust
        enum Persistence {
            Temporary,
            Persistent,
        }
        fn set_option(name: &str, value: &str, persistence: Persistence) {
            // ... logic based on persistence enum ...
        }
        // Call site: set_option("theme", "dark", Persistence::Persistent); // Clearer
        ```
    * **Good (Separate Functions):**
        ```rust
        fn set_temporary_option(name: &str, value: &str) { /* ... */ }
        fn set_persistent_option(name: &str, value: &str) { /* ... */ }
        // Call site: set_persistent_option("theme", "dark"); // Very clear
        ```

4.  **Return Values:** Functions should ideally have few return values. Complex return types can often be simplified by returning a dedicated struct or enum (like `Result<T, E>`).

5.  **Idempotency:** Aim for idempotent API surfaces where possible and practical. An idempotent operation produces the same result whether called once or multiple times (e.g., setting a state, deleting a resource that might already be deleted). This can simplify error handling and state management, especially in distributed or concurrent systems.

    * **Example (Idempotent):**
        ```rust
        // Setting a value is idempotent - calling it multiple times with the same
        // arguments results in the same final state.
        fn set_user_preference(user_id: u64, key: &str, value: &str) {
            // Database::set(user_id, key, value);
        }

        // Deleting a resource is often idempotent if it doesn't error when
        // the resource is already gone.
        fn delete_file_if_exists(path: &Path) -> io::Result<()> {
            match fs::remove_file(path) {
                Ok(()) => Ok(()),
                Err(e) if e.kind() == io::ErrorKind::NotFound => Ok(()), // Already gone, still OK
                Err(e) => Err(e),
            }
        }
        ```
    * **Example (Not Idempotent):**
        ```rust
        // Appending to a log is not idempotent - calling it multiple times adds multiple entries.
        fn append_log_message(message: &str) {
            // file.append(message);
        }
        ```

## Magic Numbers

1.  **Define Constants:** Avoid using literal numbers other than 0, 1, or 2 directly in the code if their meaning isn't immediately obvious from context. Define `const`ants with clear names instead (e.g., `const MAX_CSI_PARAMS: usize = 16;`).

    * **Bad:**
        ```rust
        fn process_status(status_code: u8) {
            if status_code == 4 { // What does 4 mean?
                // ... handle processing complete ...
            }
        }
        ```
    * **Good:**
        ```rust
        const STATUS_PROCESSING_COMPLETE: u8 = 4;

        fn process_status(status_code: u8) {
            if status_code == STATUS_PROCESSING_COMPLETE {
                // ... handle processing complete ...
            }
        }
        ```
    * **Better (Enum):**
        ```rust
        enum StatusCode {
            Pending = 1,
            InProgress = 2,
            Failed = 3,
            ProcessingComplete = 4,
        }

        fn process_status(status_code: StatusCode) {
             match status_code {
                 StatusCode::ProcessingComplete => { /* ... */ },
                 _ => { /* ... */ }
             }
        }
        ```

## Testing

1.  **Test Public API:** Unit tests (`#[test]`) should primarily focus on testing the public/exported API of a module or crate. Testing internal implementation details can make tests brittle and harder to refactor.

## Flexibility

1.  **Break Rules Sensibly:** These are guidelines, not immutable laws. If strictly adhering to a rule would result in code that is significantly more complex, less readable, or otherwise "ridiculous," use your judgment and break the rule, perhaps leaving a brief comment explaining the rationale if necessary.

