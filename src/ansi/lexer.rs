// src/ansi/lexer.rs

//! ANSI escape sequence lexer.
//! Converts a byte stream into `AnsiToken`s, processing byte by byte.

use std::{mem, str};

// Define the replacement character for invalid UTF-8 sequences
const REPLACEMENT_CHARACTER: char = '\u{FFFD}';

/// Represents a single token identified by the lexer.
#[derive(Debug, Clone, PartialEq, Eq)]
pub enum AnsiToken {
    /// A printable character.
    Print(char),
    /// A C0 control code (0x00 - 0x1F, plus DEL 0x7F for compatibility).
    C0Control(u8),
    /// A C1 control code (0x80 - 0x9F).
    C1Control(u8),
}

/// Internal state for UTF-8 decoding.
#[derive(Debug, Clone, Default)]
struct Utf8Decoder {
    buffer: [u8; 4],
    len: usize,
    expected: usize,
}

impl Utf8Decoder {
    /// Processes a single byte for UTF-8 decoding.
    /// Returns Some(char) if a character is completed, None otherwise.
    /// Returns Some(REPLACEMENT_CHARACTER) on error.
    fn decode(&mut self, byte: u8) -> Option<char> {
        if self.len == 0 {
            // Start of a new character
            if byte < 0x80 { // ASCII
                return Some(byte as char);
            } else if byte < 0xC2 { // Invalid start or continuation byte
                return Some(REPLACEMENT_CHARACTER);
            } else if byte < 0xE0 { // 2-byte sequence
                self.expected = 2;
                self.buffer[0] = byte;
                self.len = 1;
            } else if byte < 0xF0 { // 3-byte sequence
                self.expected = 3;
                self.buffer[0] = byte;
                self.len = 1;
            } else if byte < 0xF5 { // 4-byte sequence
                self.expected = 4;
                self.buffer[0] = byte;
                self.len = 1;
            } else { // Invalid start byte
                return Some(REPLACEMENT_CHARACTER);
            }
        } else {
            // Continuation byte
            if (0x80..=0xBF).contains(&byte) {
                self.buffer[self.len] = byte;
                self.len += 1;
                if self.len == self.expected {
                    let result = match str::from_utf8(&self.buffer[0..self.len]) {
                        Ok(s) => s.chars().next(), // Should always be Some(char)
                        Err(_) => Some(REPLACEMENT_CHARACTER), // Should not happen if logic is correct
                    };
                    self.reset();
                    return result.or(Some(REPLACEMENT_CHARACTER)); // Provide fallback
                }
            } else {
                // Invalid continuation byte
                self.reset();
                return Some(REPLACEMENT_CHARACTER);
            }
        }
        None // Character not yet complete
    }

    /// Resets the decoder state.
    fn reset(&mut self) {
        self.len = 0;
        self.expected = 0;
    }
}


/// The ANSI lexer structure. Processes bytes individually.
#[derive(Debug, Clone, Default)] // Added Debug derive
pub struct AnsiLexer {
    /// Internal buffer for tokens generated by `process_byte`.
    tokens: Vec<AnsiToken>,
    /// Internal state for handling multi-byte UTF-8 characters.
    utf8_decoder: Utf8Decoder,
}

impl AnsiLexer {
    /// Creates a new `AnsiLexer`.
    pub fn new() -> Self {
        AnsiLexer::default()
    }

    /// Processes a single byte. Decodes UTF-8 and buffers tokens internally.
    pub fn process_byte(&mut self, byte: u8) {
        match byte {
            // C0 Control Codes (excluding ESC)
            0x00..=0x1A | 0x1C..=0x1F => {
                self.utf8_decoder.reset(); // Controls reset UTF-8 state
                self.tokens.push(AnsiToken::C0Control(byte));
            }
            // Escape character
            0x1B => {
                self.utf8_decoder.reset(); // Controls reset UTF-8 state
                self.tokens.push(AnsiToken::C0Control(0x1B));
            }
            // C1 Control Codes
            0x80..=0x9F => {
                self.utf8_decoder.reset(); // Controls reset UTF-8 state
                self.tokens.push(AnsiToken::C1Control(byte));
            }
            // DEL character (often treated like C0)
            0x7F => {
                 self.utf8_decoder.reset(); // Controls reset UTF-8 state
                 self.tokens.push(AnsiToken::C0Control(0x7F)); // Emit DEL as C0
            }
            // Potentially printable characters (ASCII or UTF-8)
            _ => {
                if let Some(c) = self.utf8_decoder.decode(byte) {
                    self.tokens.push(AnsiToken::Print(c));
                }
                // If None, the character is incomplete, wait for more bytes.
            }
        }
    }

    /// Takes the currently buffered tokens, leaving the internal buffer empty.
    pub fn take_tokens(&mut self) -> Vec<AnsiToken> {
        // If the decoder is in the middle of a character when take_tokens is called,
        // emit a replacement character to avoid losing data/state.
        if self.utf8_decoder.len > 0 {
             self.tokens.push(AnsiToken::Print(REPLACEMENT_CHARACTER));
             self.utf8_decoder.reset();
        }
        mem::take(&mut self.tokens)
    }
}

