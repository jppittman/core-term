// src/orchestrator.rs
//! Orchestrates the main application flow, coordinating between the platform,
//! terminal emulator, ANSI parser, and renderer. This module aims to encapsulate
//! the core event processing logic, making it testable and maintainable by
//! abstracting away direct OS calls and backend specifics via the Platform trait.

use anyhow::{Context, Result};
use log::{debug, info, trace, warn}; // Removed error

use crate::ansi::commands::AnsiCommand;
use crate::ansi::AnsiParser; // Trait for AnsiProcessor
use crate::ansi::AnsiProcessor; // Specific type for Ansi commands

use crate::config::Config;
use crate::platform::actions::PlatformAction; // Updated import
use crate::platform::backends::BackendEvent;
// Assuming MouseButton, KeySymbol, Modifiers are from platform::backends and are compatible with UserInputAction where needed.
use crate::platform::backends::MouseButton; // KeySymbol, Modifiers, PlatformState removed due to warnings
use crate::platform::platform_trait::Platform;
use crate::platform::PlatformEvent; // Added for poll_events
use crate::renderer::Renderer;

// Updated imports from `term` module
use crate::term::{
    ControlEvent,   // Correctly named ControlEvent
    EmulatorAction, // Correctly named EmulatorAction
    EmulatorInput,  // Correctly named EmulatorInput
    // RenderSnapshot,    // Removed due to warning (used as type, but direct import might be unused if path is qualified)
    TerminalEmulator, // The concrete type
    UserInputAction,  // Correctly named UserInputAction
};

/// Represents the status of the orchestrator after processing an event or an iteration of its loop.
#[derive(Debug, PartialEq, Eq, Clone, Copy)]
pub enum OrchestratorStatus {
    Running,
    Shutdown,
}

pub struct AppOrchestrator<'a, P: Platform + ?Sized> {
    platform: &'a mut P,
    term_emulator: &'a mut TerminalEmulator,
    ansi_parser: &'a mut AnsiProcessor,
    renderer: Renderer,
    // A buffer for actions generated by term_emulator.interpret_input()
    // This is needed because one input event might result in one action,
    // and we process all inputs before processing all generated actions.
    pending_emulator_actions: Vec<EmulatorAction>,
}

impl<'a, P: Platform + ?Sized> AppOrchestrator<'a, P> {
    pub fn new(
        platform: &'a mut P,
        term_emulator: &'a mut TerminalEmulator,
        ansi_parser: &'a mut AnsiProcessor,
        renderer: Renderer,
    ) -> Self {
        info!("AppOrchestrator: Initializing...");
        AppOrchestrator {
            platform,
            term_emulator,
            ansi_parser,
            renderer,
            pending_emulator_actions: Vec::new(),
        }
    }

    fn handle_emulator_action_immediately(&mut self, action: EmulatorAction) -> Result<()> {
        debug!(
            "AppOrchestrator: Handling EmulatorAction immediately: {:?}",
            action
        );
        match action {
            EmulatorAction::WritePty(data) => {
                self.platform
                    .dispatch_actions(vec![PlatformAction::Write(data)])
                    .context("Failed to dispatch PTY write action")?;
            }
            EmulatorAction::SetTitle(title) => {
                self.platform
                    .dispatch_actions(vec![PlatformAction::SetTitle(title)])
                    .context("Failed to dispatch UI set title action")?;
            }
            EmulatorAction::RingBell => {
                self.platform
                    .dispatch_actions(vec![PlatformAction::RingBell])
                    .context("Failed to dispatch UI ring bell action")?;
            }
            EmulatorAction::CopyToClipboard(text) => {
                self.platform
                    .dispatch_actions(vec![PlatformAction::CopyToClipboard(text)])
                    .context("Failed to dispatch UI copy to clipboard action")?;
            }
            EmulatorAction::SetCursorVisibility(visible) => {
                self.platform
                    .dispatch_actions(vec![PlatformAction::SetCursorVisibility(visible)])
                    .context("Failed to dispatch UI set cursor visibility action")?;
            }
            EmulatorAction::RequestRedraw => {
                // This action might signal the need to set a dirty flag if we implement one,
                // or it's handled implicitly by the rendering logic checking snapshot changes.
                // For now, if renderer always checks snapshot, this is more of a hint.
                trace!("EmulatorAction::RequestRedraw received.");
            }
            EmulatorAction::RequestClipboardContent => {
                // This is an action for the platform, not directly for UI/PTY dispatch.
                // The platform itself should handle this if it's about requesting data *from* the system.
                // Or, it might be a signal to the main loop / platform to initiate a paste.
                // For now, this is a conceptual gap or needs platform-level handling.
                warn!("EmulatorAction::RequestClipboardContent received - platform interaction needed.");
            } // _ => {
              //     warn!("AppOrchestrator: Unhandled EmulatorAction during immediate processing: {:?}", action);
              // }
        }
        Ok(())
    }

    pub fn process_event_cycle(&mut self) -> Result<OrchestratorStatus> {
        trace!("AppOrchestrator: Starting new event cycle.");

        self.pending_emulator_actions.clear();

        // --- Poll for Events ---
        let events = self
            .platform
            .poll_events()
            .context("Failed to poll platform events")?;

        debug!("processing {} events", events.len());
        for platform_event in events {
            match platform_event {
                PlatformEvent::IOEvent { data: pty_data } => {
                    debug!(
                        "AppOrchestrator: Received {} bytes from PTY.",
                        pty_data.len()
                    );
                    // Use the AnsiParser trait method
                    let ansi_commands: Vec<AnsiCommand> = self.ansi_parser.process_bytes(&pty_data);
                    if !ansi_commands.is_empty() {
                        debug!(
                            "AppOrchestrator: Parsed {} ANSI commands.",
                            ansi_commands.len()
                        );
                        for command in ansi_commands {
                            if let Some(action) = self
                                .term_emulator
                                .interpret_input(EmulatorInput::Ansi(command))
                            {
                                self.pending_emulator_actions.push(action);
                            }
                        }
                    }
                }
                PlatformEvent::Backend(backend_event) => {
                    debug!(
                        "AppOrchestrator: Received BackendEvent: {:?}",
                        backend_event
                    );
                    let mut emulator_input_to_process: Option<EmulatorInput> = None;

                    match backend_event {
                        BackendEvent::CloseRequested => {
                            info!("AppOrchestrator: CloseRequested event received. Signaling shutdown.");
                            return Ok(OrchestratorStatus::Shutdown);
                        }
                        BackendEvent::Resize {
                            width_px,
                            height_px,
                        } => {
                            let platform_state = self.platform.get_current_platform_state();
                            if platform_state.font_cell_width_px > 0
                                && platform_state.font_cell_height_px > 0
                            {
                                // width_px, height_px are u16 from BackendEvent.
                                // platform_state.font_cell_..._px are usize.
                                let cols = (width_px as usize
                                    / platform_state.font_cell_width_px.max(1))
                                .max(1);
                                let rows = (height_px as usize
                                    / platform_state.font_cell_height_px.max(1))
                                .max(1);
                                info!(
                                    "AppOrchestrator: Resizing to {}x{} cells ({}x{} px, char_size: {}x{})",
                                    cols,
                                    rows,
                                    width_px,
                                    height_px,
                                    platform_state.font_cell_width_px,
                                    platform_state.font_cell_height_px
                                );
                                // Dispatch PTY resize first
                                self.platform
                                    .dispatch_actions(vec![PlatformAction::ResizePty {
                                        cols: cols as u16,
                                        rows: rows as u16,
                                    }])
                                    .context("Failed to dispatch PTY resize action")?;
                                // Then inform terminal emulator
                                emulator_input_to_process =
                                    Some(EmulatorInput::Control(ControlEvent::Resize {
                                        cols,
                                        rows,
                                    }));
                            } else {
                                warn!("AppOrchestrator: Font dimensions are zero, cannot process resize.");
                            }
                        }
                        BackendEvent::Key {
                            symbol,
                            modifiers,
                            text,
                        } => {
                            let key_input_action = UserInputAction::KeyInput {
                                symbol,
                                modifiers,
                                text: if text.is_empty() { None } else { Some(text) },
                            };
                            emulator_input_to_process = Some(EmulatorInput::User(key_input_action));
                        }
                        BackendEvent::MouseButtonPress {
                            button,
                            x,
                            y,
                            modifiers: _,
                        } => {
                            // Convert pixel to cell coordinates
                            let platform_state = self.platform.get_current_platform_state();
                            if platform_state.font_cell_width_px > 0
                                && platform_state.font_cell_height_px > 0
                            {
                                let cell_x = (x as u32
                                    / platform_state.font_cell_width_px.max(1) as u32)
                                    as usize;
                                let cell_y = (y as u32
                                    / platform_state.font_cell_height_px.max(1) as u32)
                                    as usize;

                                // Determine action based on button (example)
                                match button {
                                    MouseButton::Left => {
                                        emulator_input_to_process = Some(EmulatorInput::User(
                                            UserInputAction::StartSelection {
                                                x: cell_x,
                                                y: cell_y,
                                            },
                                        ));
                                    }
                                    MouseButton::Middle => {
                                        emulator_input_to_process = Some(EmulatorInput::User(
                                            UserInputAction::RequestPrimaryPaste,
                                        ));
                                    }
                                    // Other buttons could be mapped or ignored
                                    _ => trace!("Unhandled mouse button press: {:?}", button),
                                }
                            } else {
                                warn!("AppOrchestrator: Font dimensions are zero, cannot process mouse press.");
                            }
                        }
                        BackendEvent::MouseButtonRelease {
                            button,
                            x: _x,
                            y: _y,
                            modifiers: _,
                        } => {
                            let platform_state = self.platform.get_current_platform_state();
                            if platform_state.font_cell_width_px > 0
                                && platform_state.font_cell_height_px > 0
                            {
                                // let cell_x = (_x as u32 / platform_state.font_cell_width_px.max(1) as u32) as usize;
                                // let cell_y = (_y as u32 / platform_state.font_cell_height_px.max(1) as u32) as usize;
                                if button == MouseButton::Left {
                                    emulator_input_to_process = Some(EmulatorInput::User(
                                        UserInputAction::ApplySelectionClear,
                                    ));
                                }
                            } else {
                                warn!("AppOrchestrator: Font dimensions are zero, cannot process mouse release.");
                            }
                        }
                        BackendEvent::MouseMove { x, y, modifiers: _ } => {
                            // Corrected to MouseMove
                            let platform_state = self.platform.get_current_platform_state();
                            if platform_state.font_cell_width_px > 0
                                && platform_state.font_cell_height_px > 0
                            {
                                let cell_x = (x as u32
                                    / platform_state.font_cell_width_px.max(1) as u32)
                                    as usize; // Use x
                                let cell_y = (y as u32
                                    / platform_state.font_cell_height_px.max(1) as u32)
                                    as usize; // Use y
                                emulator_input_to_process =
                                    Some(EmulatorInput::User(UserInputAction::ExtendSelection {
                                        x: cell_x,
                                        y: cell_y,
                                    }));
                            } else {
                                warn!(
                                    "AppOrchestrator: Font dimensions are zero, cannot process mouse move."
                                );
                            }
                        }
                        BackendEvent::FocusGained => {
                            emulator_input_to_process =
                                Some(EmulatorInput::User(UserInputAction::FocusGained));
                        }
                        BackendEvent::FocusLost => {
                            emulator_input_to_process =
                                Some(EmulatorInput::User(UserInputAction::FocusLost));
                        }
                        BackendEvent::PasteData { text } => {
                            emulator_input_to_process =
                                Some(EmulatorInput::User(UserInputAction::PasteText(text)));
                        }
                    }

                    if let Some(input) = emulator_input_to_process {
                        if let Some(action) = self.term_emulator.interpret_input(input) {
                            self.pending_emulator_actions.push(action);
                        }
                    }
                } // End of BackendEvent processing
            } // End of match platform_event
        } // End of for platform_event in events

        // --- Process Emulator Actions ---
        // Iterate over a clone if actions can generate new actions, or use a while loop
        for action in self.pending_emulator_actions.drain(..).collect::<Vec<_>>() {
            self.handle_emulator_action_immediately(action)?;
        }

        // --- Render ---
        // The dirtiness is tracked per line in RenderSnapshot.
        // Renderer::prepare_render_commands will use this. If no lines are dirty, it will return few/no commands.
        // No explicit is_dirty() check on term_emulator is available/needed if snapshot handles it.
        let snapshot: crate::term::RenderSnapshot = self.term_emulator.get_render_snapshot(); // Use fully qualified path
        let config = Config::default(); // Placeholder for Config access
        let platform_state = self.platform.get_current_platform_state();
        let render_commands =
            self.renderer
                .prepare_render_commands(&snapshot, &config, &platform_state);

        if !render_commands.is_empty() {
            debug!(
                "AppOrchestrator: Sending {} render commands to UI.",
                render_commands.len()
            );
            self.platform
                .dispatch_actions(vec![PlatformAction::Render(render_commands)])
                .context("Failed to dispatch UI render action")?;
        }

        // Regarding clear_dirty_flags:
        // The `Screen`'s dirty flags are typically cleared after they have been successfully rendered or
        // incorporated into a snapshot that is then rendered.
        // `TerminalEmulator::get_render_snapshot()` seems to be where dirty flags are read.
        // The actual clearing might need to be a method on `TerminalEmulator` or `Screen`
        // called after successful rendering by the platform.
        // For now, this step is omitted as no direct `clear_dirty_flags` method is on TerminalEmulator.
        // This might mean lines stay dirty, or `get_render_snapshot` implicitly clears them (less likely).
        // This needs clarification based on `Screen`'s behavior.

        Ok(OrchestratorStatus::Running)
    }
}
