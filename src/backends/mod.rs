// src/backends/mod.rs

use crate::term::Term;
use anyhow::Result;
use std::os::unix::io::RawFd;

// Re-export backend implementations
pub mod console;
pub mod x11;

pub use console::ConsoleBackend;
pub use x11::XBackend;

/// Represents the different kinds of events a backend might need to process.
#[derive(Debug, Clone)]
pub enum BackendEvent<'a> {
    /// A keyboard key was pressed or released.
    Key {
        /// Platform-specific key symbol (e.g., X11 KeySym).
        keysym: u32,
        /// Text generated by the key event (e.g., from XLookupString or similar).
        text: &'a str, // Use lifetime to avoid allocation if text comes from a temporary buffer
    },
    /// The window or display area was resized.
    Resize {
        /// New width in pixels.
        width_px: u16,
        /// New height in pixels.
        height_px: u16,
    },
    /// The application received a request to close (e.g., user clicked the close button).
    /// The `run` loop should typically return `Ok(true)` upon receiving this.
    CloseRequested,
    /// Input focus gained.
    FocusGained,
    /// Input focus lost.
    FocusLost,
    // TODO: Add other events like Mouse clicks, Mouse movement, Paste events etc.
}


/// Defines the interface for different terminal backends (UI, input/output handling).
pub trait TerminalBackend {
    /// Creates and initializes a new backend instance.
    ///
    /// # Arguments
    ///
    /// * `width` - Initial terminal width in columns.
    /// * `height` - Initial terminal height in rows.
    fn new(width: usize, height: usize) -> Result<Self> where Self: Sized;

    /// Runs the main event loop for the backend.
    ///
    /// This function typically blocks, waiting for events from the underlying UI toolkit
    /// or other sources. It should translate these native events into `BackendEvent`
    /// variants and call `handle_event`. It also needs to handle PTY interaction,
    /// potentially using non-blocking reads or integrating the PTY fd into the event loop.
    ///
    /// # Arguments
    ///
    /// * `term` - A mutable reference to the terminal state.
    /// * `pty_fd` - The raw file descriptor for the PTY master side.
    ///
    /// # Returns
    ///
    /// * `Ok(true)` if the terminal session should exit (e.g., received `BackendEvent::CloseRequested`).
    /// * `Ok(false)` to indicate the event loop should continue (though `run` usually loops internally).
    /// * `Err` if a fatal error occurs.
    fn run(&mut self, term: &mut Term, pty_fd: RawFd) -> Result<bool>;

    /// Handles a specific backend event.
    ///
    /// This method is called by `run` after translating a native UI event
    /// into a `BackendEvent`. It contains the logic for updating the terminal state,
    /// writing to the PTY, or performing other actions based on the event type.
    ///
    /// # Arguments
    ///
    /// * `event` - The `BackendEvent` to handle.
    /// * `term` - A mutable reference to the terminal state.
    /// * `pty_fd` - The PTY master file descriptor.
    fn handle_event(&mut self, event: BackendEvent, term: &mut Term, pty_fd: RawFd) -> Result<()>;

    /// Renders the current terminal state to the display.
    ///
    /// # Arguments
    ///
    /// * `term` - An immutable reference to the terminal state to be drawn.
    fn draw(&mut self, term: &Term) -> Result<()>;

    /// Cleans up backend resources (e.g., close display connection, free fonts).
    fn cleanup(&mut self) -> Result<()>;
}

