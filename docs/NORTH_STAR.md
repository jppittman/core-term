# core Terminal Design Document - Target Architecture

**Version:** 1.9.4
**Date:** 2025-05-23
**Status:** Active

## 1. Introduction & Vision

`core` aims to be a correct, reasonably performant, and maintainable terminal emulator written in Rust. This document outlines a target architecture refactored from the initial `st`-inspired design towards a clearer separation of concerns, adopting an **Interpreter/Virtual Machine (VM) model** for its core logic.

The central idea is that the terminal's state machine (`TerminalEmulator`) acts as a self-contained VM. It processes a defined set of inputs (`EmulatorInput`) derived from PTY output and user actions, updates its internal state based on these inputs, and signals required external side-effects (`EmulatorAction`) without performing direct I/O. This approach enhances modularity, testability, and clarifies the role of each component.

A core principle is **simplicity and stability**, favoring well-established, CPU-based rendering techniques over GPU acceleration to avoid complex driver dependencies.

### 1.1. Core Feature Scope & Philosophy

A primary functional goal is to achieve feature parity with the `st` (simple terminal) terminal emulator, focusing on its core terminal emulation capabilities (VT100/VT220/XTerm compatibility, character set handling, SGR attributes, mouse reporting, etc.). Configurable copy/paste functionality is also a key feature.

Following the suckless philosophy, features explicitly out of scope, in line with the project's principles of simplicity and encouraging composition with dedicated tools (like `tmux`), include:
* Built-in scrollback.
* Advanced font rendering features like ligatures or complex text shaping beyond a monospaced grid.
* Image support or other graphical extensions beyond standard terminal capabilities.

## 2. Core Concepts & Design Principles

* **Configuration (`Config`):** Loaded once at startup (typically in `main.rs`) and made globally accessible via a mechanism like `std::sync::OnceLock` or `std::lazy::SyncLazy` (e.g., `static CONFIG: OnceLock<Config>`). Components needing configuration settings access them through this static instance.
* **Terminal Emulator (Interpreter/VM):** The core state machine (`struct TerminalEmulator`). Maintains the terminal grid, cursor, attributes, modes, selection state, etc. Interprets `EmulatorInput` to modify state (including internal dirty flags) and signals `EmulatorAction`s. **Does not perform I/O or rendering directly.** Accesses configuration settings (e.g., for behavior flags) via the global static `CONFIG`.
* **Emulator Input (Instruction Set):** `enum EmulatorInput` wrapping:
    * `AnsiCommand` (from PTY output).
    * `UserInputAction` (derived from `BackendEvent`s for user interaction or platform signals, using an abstract representation). Examples include key presses, mouse actions, and explicit copy/paste requests.
    * `ControlEvent` (internal signals, e.g., `FrameRendered`).
* **Parser Pipeline:** (`AnsiLexer`, `AnsiParser`) Converts PTY byte stream -> `Vec<AnsiCommand>`. Runs outside the `TerminalEmulator`.
* **Emulator Action (Side-Effect Request):** `enum EmulatorAction` returned by `TerminalEmulator` (e.g., `WritePty`, `SetTitle`, `RingBell`, `CopyToClipboard`, `RequestClipboardContent`) for the `AppOrchestrator` to execute.
* **AppOrchestrator (`orchestrator.rs`):** Central coordinator. Owns the main event loop, manages PTY I/O, drives the parser, feeds `EmulatorInput` to `TerminalEmulator`, executes `EmulatorAction`s (including clipboard operations), and orchestrates rendering by passing `RenderCommand`s (generated by the `Renderer` and augmented by itself) to the `Driver`. Accesses configuration (e.g., for keybindings) via the global static `CONFIG`. Retrieves platform state (like font metrics, scale factor, event FD) from the `Driver` via a consolidated state snapshot.
* **BackendEvent (Abstract Platform Input):** An `enum BackendEvent` (defined in `backends` module) representing platform-agnostic events from the `Driver`. Key events use abstract `KeySymbol` and `Modifiers` types (also defined in `backends` module) rather than platform-specific codes. Mouse events provide coordinates in **cell-based units (column, row)** relative to the terminal grid.
* **RenderCommand (Abstract Platform Output):** An `enum RenderCommand` (defined in `backends` module) defining a platform-agnostic intermediate language for all rendering and display-related operations. The `Renderer` produces drawing-related commands, and the `AppOrchestrator` may add other commands (like setting window title) before sending the batch to the `Driver`.
* **Rendering Driver (`Driver` Trait):** Interface implemented by backend-specific components (`XDriver`, `ConsoleDriver`, and planned `WaylandDriver`, `MacosDriver`). Responsibilities:
    * Window/display setup and management. Accesses initial configuration (e.g., font settings) via the global static `CONFIG`.
    * **Translating platform-specific input events into the abstract `BackendEvent`s (using the common `KeySymbol`, `Modifiers`, etc. types).** This includes converting mouse pixel coordinates to cell coordinates.
    * **Executing a list of abstract `RenderCommand`s,** translating them into platform-specific API calls.
    * Provides a consolidated snapshot of its state (`PlatformState`) including event FD, font metrics (cell pixel dimensions), display scale factor, and current display dimensions in pixels.
* **PlatformState (`struct PlatformState`):** A struct (defined in `backends` module) that consolidates various pieces of state provided by the `Driver`, such as event FD, font cell dimensions, scale factor, and total display pixel dimensions.
* **Renderer (`Renderer` Struct):** **Backend-agnostic** component responsible for:
    * Requesting a `RenderSnapshot` of the current terminal state from the `TerminalEmulator`.
    * Iterating through the `RenderSnapshot` and translating lines marked as dirty (and selection state) into a list of drawing-related `RenderCommand`s.
    * Implementing common rendering logic and optimizations (e.g., coalescing runs of characters with identical attributes into fewer `RenderCommand`s).
* **Functional Influence & Modularity:** While Rust supports object-oriented patterns, the design prefers a more data-oriented and functional approach where practical. Components aim for well-defined inputs and outputs (like `RenderSnapshot`, `Vec<RenderCommand>`, `BackendEvent`), and internal state is managed explicitly. Side effects are primarily handled by the `AppOrchestrator` (dispatching) and `Driver` (executing commands and translating platform events). Modularity is achieved through composition and clear interfaces. This translates to preferring immutable data structures for messages/snapshots where feasible, composing behavior from smaller, focused functions, and isolating state mutations within specific components (primarily the `TerminalEmulator`).

## 3. Component Responsibilities & Structure

* **`main.rs`:**
    * Entry point, initial setup.
    * Loads the `Config` structure (e.g., from a file or defaults).
    * **Initializes the global static `CONFIG` (e.g., `static CONFIG: OnceLock<Config>`) with the loaded configuration.**
    * Instantiates all major components (which will then access `CONFIG` statically as needed).
    * Creates and runs the `AppOrchestrator`.
* **`orchestrator.rs` (`AppOrchestrator` struct):**
    * Owns the main `epoll` (or equivalent) event loop, configured using `event_fd` from `Driver`'s `PlatformState`.
    * Monitors PTY FD and Driver FD.
    * **PTY Output Handling:** Reads PTY -> `AnsiParser` -> `Vec<AnsiCommand>`. For each, `EmulatorInput::Ansi` -> `term.interpret_input()` -> Handles `EmulatorAction`.
    * **Driver Event Handling:** Polls `Driver` -> `driver.process_events()` (which returns `Vec<BackendEvent>`).
        * Handles `BackendEvent::Resize { width_px, height_px }`: Calls `driver.get_platform_state()`. Uses `platform_state.font_cell_width_px`, `platform_state.font_cell_height_px` (which account for `platform_state.scale_factor`) along with the event's `width_px`, `height_px` (or `platform_state.display_width_px`, `platform_state.display_height_px`) to calculate new grid dimensions (cols, rows). Informs `pty.resize()`, `term.update_dimensions()`, and `term.update_cell_pixel_size(platform_state.font_cell_width_px, platform_state.font_cell_height_px)`.
        * Handles `BackendEvent::CloseRequested` by signaling shutdown.
        * Handles `BackendEvent::Key`:
            * Accesses `CONFIG.get().unwrap().keybindings` to check against configured hotkeys (e.g., for copy/paste). If a hotkey matches, creates appropriate `EmulatorInput::User(UserInputAction::InitiateCopy)` or `EmulatorInput::User(UserInputAction::InitiatePaste)`.
            * Otherwise, creates `EmulatorInput::User(UserInputAction::KeyInput { symbol, modifiers, text })`.
        * Handles `BackendEvent::Mouse`: Creates `EmulatorInput::User(UserInputAction::MouseInput { col, row, event_type, button, modifiers })`.
        * Feeds `EmulatorInput` to `term.interpret_input()` -> Handles resulting `EmulatorAction`.
        * For `EmulatorAction::CopyToClipboard(text)`: Uses a clipboard library to set system clipboard.
        * For `EmulatorAction::RequestClipboardContent`: Uses a clipboard library to get system clipboard content, then feeds it to `term.interpret_input(EmulatorInput::User(UserInputAction::PasteText(clipboard_content)))`.
    * **Rendering Orchestration:**
        * Calls `renderer.prepare_render_commands(&mut term)` to get drawing-related `RenderCommand`s.
        * Augments this list with other `RenderCommand`s derived from `EmulatorAction`s (e.g., `SetWindowTitle`, `RingBell`) processed in the current loop iteration.
        * Appends a `RenderCommand::PresentFrame`.
        * Sends the complete `Vec<RenderCommand>` to `driver.execute_commands()`.
        * If successful, sends `EmulatorInput::Control(ControlEvent::FrameRendered)` to `term.interpret_input()`.
* **`term` Module (`TerminalEmulator` struct, `screen.rs`, `cursor.rs`, `selection.rs` etc.):**
    * Defines `TerminalEmulator`, `EmulatorInput` (including `UserInputAction`, `ControlEvent`), `EmulatorAction`, `RenderSnapshot`, `Selection`, and related data structures.
    * Holds all terminal state (grid, cursor, attributes, modes, selection state, internal dirty flags for each line, cell pixel dimensions for SGR pixel reporting). **No built-in scrollback.** Accesses behavioral settings from the global `CONFIG` as needed.
    * `interpret_input(EmulatorInput) -> Option<EmulatorAction>`: Updates internal state (marking lines dirty as needed) and signals necessary side-effects.
        * Handles `UserInputAction::InitiateCopy`: Extracts selected text, returns `EmulatorAction::CopyToClipboard(text)`.
        * Handles `UserInputAction::InitiatePaste`: Returns `EmulatorAction::RequestClipboardContent`.
        * Handles `UserInputAction::PasteText(text)`: Processes pasted text, typically by converting it to a sequence of character inputs for the PTY.
    * `update_dimensions(cols: usize, rows: usize)`: Updates internal grid dimensions and related state. Marks all lines as dirty.
    * `update_cell_pixel_size(cell_width_px: f64, cell_height_px: f64)`: Stores cell pixel dimensions for SGR pixel mode reporting.
    * `get_render_snapshot() -> RenderSnapshot`: Provides a snapshot of the *entire current screen state*, including per-line dirty flags and selection information. This method is a read-only operation regarding the terminal's internal dirty flags.
* **`ansi` Module (`AnsiParser`, `lexer`, `parser`, `commands`):**
    * Parser pipeline components. Defines `AnsiCommand`.
* **`backends` Module (`Driver` trait, `BackendEvent` enum, `RenderCommand` enum, `PlatformState` struct, `x11.rs`, `console.rs`, future `wayland.rs`, `macos.rs`):**
    * Defines `trait Driver` with methods like `process_events() -> Result<Vec<BackendEvent>>`, `get_platform_state() -> PlatformState`, and `execute_commands(commands: Vec<RenderCommand>) -> Result<()`.
    * Defines `struct PlatformState { event_fd: Option<RawFd>, font_cell_width_px: usize, font_cell_height_px: usize, scale_factor: f64, display_width_px: u16, display_height_px: u16 }`. Font dimensions within `PlatformState` already account for the scale factor.
    * Defines common, platform-agnostic event-related types:
        * `enum BackendEvent`
        * `enum KeySymbol`
        * `bitflags! struct Modifiers`
        * `enum MouseButton`, `enum MouseEventType`
    * Defines `enum RenderCommand` (the Lingua Franca for rendering).
    * Concrete `Driver` implementations (`x11.rs`, `console.rs`, etc.):
        * Translate platform-specific events (including mouse pixel coordinates) to the abstract `BackendEvent`s (using the common `KeySymbol`, `Modifiers`, etc.). May use a shared utility function like `pixels_to_cells(pixel_x, pixel_y, cell_width_px, cell_height_px)` for coordinate conversion using cell dimensions from their internal state (which also populates `PlatformState`).
        * For macOS, event loop integration might involve an internal pipe to signal the `AppOrchestrator`'s `epoll` loop.
* **`renderer` Module (`Renderer` struct):**
    * **Backend-agnostic.**
    * `prepare_render_commands(&mut self, term: &mut dyn TerminalInterface) -> Vec<RenderCommand>`:
        * Calls `let snapshot = term.get_render_snapshot();`.
        * Iterates `snapshot.lines`. For each line where `is_dirty` is true, or if affected by selection, it processes the line's cell data.
        * Generates drawing-related `RenderCommand`s (e.g., `ClearAll` if first frame, `DrawTextRun`, `FillRect`) based on the snapshot, including visual representation of the selection.
        * Generates `RenderCommand`s for cursor drawing if the cursor is visible and its state requires an update based on the snapshot.
        * Returns the `Vec<RenderCommand>`.
* **`config` Module (`config.rs`):**
    * Defines `Config` struct, including `KeybindingsConfig` with `KeyCombination { symbol: KeySymbol, modifiers: Modifiers }` for actions like copy and paste. (Requires `KeySymbol` and `Modifiers` to be accessible, e.g., from `crate::backends`).
    * **This module will also likely define the `static CONFIG: OnceLock<Config>` and a public `get()` function to access it.**
* **`os` Module (`pty.rs`, `epoll.rs`):**
    * Provides PTY and event monitoring utilities.
* **`color` Module:**
    * Defines color representations and utilities. `ConcreteColor` (a resolved `Color`) would be used in `RenderCommand`s.

## 4. Data & Control Flow

1.  **PTY Output:** (Same as v1.8)
2.  **User Input (Key):** `Driver` detects platform-specific key event -> Translates to abstract `BackendEvent::Key` -> `AppOrchestrator` calls `driver.process_events()` -> `AppOrchestrator` receives `BackendEvent::Key`.
    * If hotkey (e.g., copy/paste, determined by checking `CONFIG`): `AppOrchestrator` calls `term.interpret_input(EmulatorInput::User(UserInputAction::InitiateCopy/Paste))` -> Handles `EmulatorAction` (e.g., `CopyToClipboard`, `RequestClipboardContent`). For paste, gets clipboard content, then `term.interpret_input(EmulatorInput::User(UserInputAction::PasteText(...)))`.
    * Else: `AppOrchestrator` calls `term.interpret_input(EmulatorInput::User(UserInputAction::KeyInput(...)))` -> `EmulatorAction::WritePty(bytes)` returned -> `AppOrchestrator` writes bytes to PTY.
3.  **User Input (Mouse):** `Driver` detects platform mouse event (pixels) -> Converts to cell coordinates -> Translates to abstract `BackendEvent::Mouse { col, row, ... }` -> `AppOrchestrator` calls `driver.process_events()` -> `AppOrchestrator` receives `BackendEvent::Mouse` -> `AppOrchestrator` calls `term.interpret_input(EmulatorInput::User(UserInputAction::MouseInput(...)))` -> `TerminalEmulator` updates selection state or sends mouse report via `EmulatorAction::WritePty`.
4.  **User Input (Resize):** `AppOrchestrator` receives `BackendEvent::Resize`. Calls `driver.get_platform_state()` and uses the information to calculate new grid dimensions and update `TerminalEmulator` and PTY.
5.  **Rendering & Dirty Flag Clearing:** (Same as v1.8, with `Renderer` generating `RenderCommand`s for cursor and selection based on `RenderSnapshot`).

## 5. Benefits of this Architecture

* **Testability:** `TerminalEmulator` is testable. `Renderer` can be tested for correct `RenderCommand` generation. `Driver`s can be tested by feeding them `RenderCommand`s and by simulating platform events to check `BackendEvent` translation. For planned `WaylandDriver` and `MacosDriver`, mock platform adapters (e.g., `MockWaylandAdapter`, `MockMacosAdapter`) will be beneficial for testing their core translation logic without full platform dependencies, similar to how an `XAdapter` might be used for the `XDriver`.
* **Separation of Concerns:** Extremely clear boundaries. `Renderer` is purely a translator from terminal state to abstract render operations. `Driver`s are purely translators between platform specifics and the abstract `RenderCommand`/`BackendEvent` languages.
* **Maintainability & Extensibility:** Adding new backends means implementing the `Driver` trait (translation logic). Rendering logic changes are confined to `Renderer`. Terminal emulation logic is in `TerminalEmulator`.
* **Clarity:** The "intermediate language" approach for both `RenderCommand` (output) and `BackendEvent` (input) makes the system's interfaces very explicit. Global static access to `Config` (once initialized) simplifies dependency injection for widely needed settings. The `Driver` trait is lean, primarily for event production, command execution, and a consolidated state snapshot.
* **Stability:** Avoids complex GPU rendering dependencies.

## 6. Future Considerations

* **Platform Support (Wayland, macOS):**
    * New `WaylandDriver` and `MacosDriver` implementations are planned.
    * The `Driver` trait's `get_platform_state()` will provide HiDPI scale factor.
    * macOS event loop integration will likely use a pipe-based mechanism to signal the `AppOrchestrator`'s main event loop.
    * Testing these drivers will be aided by mock platform adapters as noted in Section 5.
* **Configuration:** (Addressed by `Config` struct and global static access via `OnceLock`).
* **Error Handling:** Consistent and robust error propagation. Errors originating from I/O (PTY, Driver) or platform interactions should generally propagate up to the `AppOrchestrator`, which will log them and decide whether to attempt recovery or signal a shutdown. The `TerminalEmulator` itself, as a state machine, should aim to handle all defined `EmulatorInput` variants gracefully, potentially ignoring malformed or unsupported sequences rather than erroring, to maintain robustness.
* **Performance:** Profiling `RenderSnapshot` creation, `RenderCommand` generation, and `Driver` execution/translation. The design prioritizes correctness and clarity; performance optimizations will be guided by profiling after core functionality is stable.
* **`RenderSnapshot` Definition (Refined):**
    ```rust
    // Example structure, to be precisely defined in `term` module.
    pub struct RenderSnapshot {
        pub dimensions: (usize, usize), // cols, rows
        pub lines: Vec<SnapshotLine>,
        pub cursor_state: Option<CursorRenderState>, // Contains info for drawing the cursor
        pub selection_state: Option<SelectionRenderState>, // Info for drawing selection highlighting
    }

    pub struct SnapshotLine {
        pub is_dirty: bool, // Was this line dirty at the time of snapshot?
        pub cells: Vec<Glyph>, // Full glyph data for the line
    }

    pub struct CursorRenderState { // Information needed by Renderer to generate cursor RenderCommands
        pub x: usize, // Physical x of the cell the cursor is on/starts at
        pub y: usize, // Physical y
        pub shape: CursorShape, // e.g., Block, Underline, Bar
        pub is_visible: bool,
        pub cell_char_underneath: char, // Character in the cell (could be space)
        pub cell_attributes_underneath: Attributes, // Attributes of the cell
    }

    pub struct SelectionRenderState {
        pub start_coords: (usize, usize), // col, row
        pub end_coords: (usize, usize),   // col, row
        pub mode: SelectionMode,          // e.g., Normal, Block
        // Potentially other visual hints for the renderer
    }
    ```
* **`RenderCommand` Definition (Lingua Franca):**
    ```rust
    // Example structure, to be defined in `backends` module.
    // ConcreteColor would be a resolved Color (e.g., an RGB struct or enum variant).
    // AttrFlagsForRender would be a subset of AttrFlags relevant for visual rendering.
    pub enum RenderCommand {
        // Drawing Commands
        ClearAll { bg: ConcreteColor },
        DrawTextRun {
            x: usize, y: usize,
            text: String,
            fg: ConcreteColor, bg: ConcreteColor,
            flags: AttrFlagsForRender,
            is_selected: bool, // Hint for renderer to potentially alter appearance for selected text
        },
        FillRect {
            x: usize, y: usize,
            width: usize, height: usize,
            color: ConcreteColor,
            is_selection_bg: bool, // Hint if this rect is for selection background
        },
        // Display & Platform Operations
        SetCursorVisibility { visible: bool }, // For Driver's native cursor, if any
        SetWindowTitle { title: String },
        RingBell,
        // Frame Control
        PresentFrame, // Signals the end of a frame's commands and to update the display
    }
    ```
* **`PlatformState` Definition (New):**
    ```rust
    // Example structure, to be defined in `backends` module.
    // Consolidates state provided by the Driver.
    pub struct PlatformState {
        pub event_fd: Option<RawFd>,
        pub font_cell_width_px: usize,
        pub font_cell_height_px: usize, // These dimensions account for scale_factor
        pub scale_factor: f64,
        pub display_width_px: u16,
        pub display_height_px: u16,
    }
    ```
* **`BackendEvent` Definition (Abstract Platform Input):**
    ```rust
    // Example structure, to be defined in `backends` module.
    // KeySymbol, Modifiers, MouseButton, MouseEventType are common types defined here.
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub enum KeySymbol { /* As previously defined in discussions: Char(char), Enter, Backspace, etc. */ }
    bitflags! {
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
        pub struct Modifiers: u8 { /* As previously defined: SHIFT, CONTROL, ALT, SUPER */ }
    }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub enum MouseButton { /* Left, Middle, Right, ScrollUp, ScrollDown, etc. */ }
    #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
    pub enum MouseEventType { /* Press, Release, Move */ }

    pub enum BackendEvent {
        Key {
            symbol: KeySymbol,
            modifiers: Modifiers,
            text: Option<String>, // Text generated by IME or key press
        },
        Mouse {
            event_type: MouseEventType,
            col: usize, // 0-based cell column
            row: usize, // 0-based cell row
            button: MouseButton,
            modifiers: Modifiers,
        },
        Resize { width_px: u16, height_px: u16 }, // Provides new total pixel dimensions of the window/display
        FocusGained,
        FocusLost,
        CloseRequested,
        // Other platform events as needed
    }
    ```
* **`EmulatorInput::UserInputAction` Definition:**
    ```rust
    // Example, to be defined in `term` module.
    // Uses KeySymbol, Modifiers, etc. from the `backends` module.
    pub enum UserInputAction {
        KeyInput { symbol: KeySymbol, modifiers: Modifiers, text: Option<String> },
        MouseInput { col: usize, row: usize, event_type: MouseEventType, button: MouseButton, modifiers: Modifiers },
        InitiateCopy,
        InitiatePaste,
        PasteText(String), // Content from clipboard to be pasted
        // ... other user-driven actions
    }
    ```
* **`EmulatorInput::ControlEvent` Definition:**
    ```rust
    // Example, to be defined in `term` module.
    pub enum ControlEvent {
        FrameRendered,
    }
    ```
* **`EmulatorAction` Definition (Additions):**
    ```rust
    // Example, to be defined in `term` module.
    pub enum EmulatorAction {
        WritePty(Vec<u8>),
        SetTitle(String),
        RingBell,
        CopyToClipboard(String),    // Request to copy text to clipboard
        RequestClipboardContent,    // Request to get content from clipboard
        // ... other actions
    }
    ```
* **Plugin System (Exploratory - Event Filter Model):**
    * Post core-stability, (maybe just for fun) investigate a WASM-based plugin system where plugins act primarily as filters or transformers for `EmulatorInput` and potentially `EmulatorAction` streams. This model would aim to allow extensibility by modifying the data flow to/from the `TerminalEmulator`. *Further evolution could explore more deeply integrated plugins interacting with other pipeline phases if a clear need and safe, performant mechanism can be identified.*
    * Key challenges would involve designing an efficient and secure host-WASM interface, managing plugin state, and addressing potential performance overhead.

