# core Terminal Design Document - Target Architecture

**Version:** 1.8
**Date:** 2025-05-16
**Status:** Active

## 1. Introduction & Vision

`core` aims to be a correct, reasonably performant, and maintainable terminal emulator written in Rust. This document outlines a target architecture refactored from the initial `st`-inspired design towards a clearer separation of concerns, adopting an **Interpreter/Virtual Machine (VM) model** for its core logic.

The central idea is that the terminal's state machine (`TerminalEmulator`) acts as a self-contained VM. It processes a defined set of inputs (`EmulatorInput`) derived from PTY output and user actions, updates its internal state based on these inputs, and signals required external side-effects (`EmulatorAction`) without performing direct I/O. This approach enhances modularity, testability, and clarifies the role of each component.

A core principle is **simplicity and stability**, favoring well-established, CPU-based rendering techniques over GPU acceleration to avoid complex driver dependencies.

### 1.1. Core Feature Scope & Philosophy

A primary functional goal is to achieve feature parity with the `st` (simple terminal) terminal emulator, focusing on its core terminal emulation capabilities (VT100/VT220/XTerm compatibility, character set handling, SGR attributes, mouse reporting, etc.).

Following the suckless philosophy, features explicitly out of scope, in line with the project's principles of simplicity and encouraging composition with dedicated tools (like `tmux`), include:
* Built-in scrollback.
* Advanced font rendering features like ligatures or complex text shaping beyond a monospaced grid.
* Image support or other graphical extensions beyond standard terminal capabilities.

## 2. Core Concepts & Design Principles

* **Terminal Emulator (Interpreter/VM):** The core state machine (`struct TerminalEmulator`). Maintains the terminal grid, cursor, attributes, modes, etc. Interprets `EmulatorInput` to modify state (including internal dirty flags) and signals `EmulatorAction`s. **Does not perform I/O or rendering directly.**
* **Emulator Input (Instruction Set):** `enum EmulatorInput` wrapping:
    * `AnsiCommand` (from PTY output).
    * `BackendEvent` (from user interaction or platform signals, using an abstract representation).
    * `ControlEvent` (internal signals, e.g., `FrameRendered`).
* **Parser Pipeline:** (`AnsiLexer`, `AnsiParser`) Converts PTY byte stream -> `Vec<AnsiCommand>`. Runs outside the `TerminalEmulator`.
* **Emulator Action (Side-Effect Request):** `enum EmulatorAction` returned by `TerminalEmulator` (e.g., `WritePty`, `SetTitle`, `RingBell`) for the `AppOrchestrator` to execute.
* **AppOrchestrator (`orchestrator.rs`):** Central coordinator. Owns the main event loop, manages PTY I/O, drives the parser, feeds `EmulatorInput` to `TerminalEmulator`, executes `EmulatorAction`s, and orchestrates rendering by passing `RenderCommand`s (generated by the `Renderer` and augmented by itself) to the `Driver`.
* **BackendEvent (Abstract Platform Input):** An `enum BackendEvent` defining a platform-agnostic representation of events originating from the `Driver` (e.g., key presses, mouse events, resize, focus changes). Key events, for instance, are represented abstractly (e.g., `KeySymbol::Enter`, `KeySymbol::Char('a')`, `KeySymbol::UpArrow` with associated modifiers) rather than using platform-specific codes like X11 KeySyms directly in this enum.
* **RenderCommand (Abstract Platform Output):** An `enum RenderCommand` defining a platform-agnostic intermediate language for all rendering and display-related operations. The `Renderer` produces drawing-related commands, and the `AppOrchestrator` may add other commands (like setting window title) before sending the batch to the `Driver`.
* **Rendering Driver (`Driver` Trait):** Interface implemented by backend-specific components (`XDriver`, `ConsoleDriver`). Responsibilities:
    * Window/display setup and management.
    * **Translating platform-specific input events into abstract `BackendEvent`s.**
    * **Executing a list of abstract `RenderCommand`s,** translating them into platform-specific API calls.
    * Provides necessary info like event FD, font metrics, and current display dimensions.
    * Offers a method to calculate character cell dimensions (columns, rows) from pixel dimensions (e.g., `get_dimensions_cells(width_px, height_px) -> (usize, usize)`).
* **Renderer (`Renderer` Struct):** **Backend-agnostic** component responsible for:
    * Requesting a `RenderSnapshot` of the current terminal state from the `TerminalEmulator`.
    * Iterating through the `RenderSnapshot` and translating lines marked as dirty into a list of drawing-related `RenderCommand`s.
    * Implementing common rendering logic and optimizations (e.g., coalescing runs of characters with identical attributes into fewer `RenderCommand`s).
* **Functional Influence & Modularity:** While Rust supports object-oriented patterns, the design prefers a more data-oriented and functional approach where practical. Components aim for well-defined inputs and outputs (like `RenderSnapshot`, `Vec<RenderCommand>`, `BackendEvent`), and internal state is managed explicitly. Side effects are primarily handled by the `AppOrchestrator` (dispatching) and `Driver` (executing commands and translating platform events). Modularity is achieved through composition and clear interfaces. This translates to preferring immutable data structures for messages/snapshots where feasible, composing behavior from smaller, focused functions, and isolating state mutations within specific components (primarily the `TerminalEmulator`).

## 3. Component Responsibilities & Structure

* **`main.rs`:**
    * Entry point, initial setup.
    * Instantiates all major components.
    * Creates and runs the `AppOrchestrator`.
* **`orchestrator.rs` (`AppOrchestrator` struct):**
    * Owns the main `epoll` (or equivalent) event loop.
    * Monitors PTY FD and Driver FD.
    * **PTY Output Handling:** Reads PTY -> `AnsiParser` -> `Vec<AnsiCommand>`. For each, `EmulatorInput::Ansi` -> `term.interpret_input()` -> Handles `EmulatorAction`.
    * **Driver Event Handling:** Polls `Driver` -> `driver.process_events()` (which returns `Vec<BackendEvent>`).
        * Handles `BackendEvent::Resize`: Calls `driver.get_dimensions_cells()` -> `pty.resize()`, `term.update_dimensions()`.
        * Handles `BackendEvent::CloseRequested` by signaling shutdown.
        * Other `BackendEvent`s (e.g., abstract key/mouse events): Creates `EmulatorInput::User` -> `term.interpret_input()` -> Handles `EmulatorAction`.
    * **Rendering Orchestration:**
        * Calls `renderer.prepare_render_commands(&mut term)` to get drawing-related `RenderCommand`s.
        * Augments this list with other `RenderCommand`s derived from `EmulatorAction`s (e.g., `SetWindowTitle`, `RingBell`) processed in the current loop iteration.
        * Appends a `RenderCommand::PresentFrame`.
        * Sends the complete `Vec<RenderCommand>` to `driver.execute_commands()`.
        * If successful, sends `EmulatorInput::Control(ControlEvent::FrameRendered)` to `term.interpret_input()`.
* **`term` Module (`TerminalEmulator` struct, `screen.rs`, `cursor.rs`, etc.):**
    * Defines `TerminalEmulator`, `EmulatorInput` (including `ControlEvent`), `EmulatorAction`, `RenderSnapshot`, and related data structures for the snapshot.
    * Holds all terminal state (grid, cursor, attributes, modes, internal dirty flags for each line). **No built-in scrollback.**
    * `interpret_input(EmulatorInput) -> Option<EmulatorAction>`: Updates internal state (marking lines dirty as needed) and signals necessary side-effects. Handles `ControlEvent::FrameRendered` by clearing all internal dirty line flags.
    * `update_dimensions(cols: usize, rows: usize)`: Updates internal grid dimensions and related state. Marks all lines as dirty.
    * `get_render_snapshot() -> RenderSnapshot`: Provides a snapshot of the *entire current screen state*, including per-line dirty flags. This method is a read-only operation regarding the terminal's internal dirty flags.
* **`ansi` Module (`AnsiParser`, `lexer`, `parser`, `commands`):**
    * Parser pipeline components. Defines `AnsiCommand`.
* **`backends` Module (`Driver` trait, `BackendEvent` enum, `RenderCommand` enum, `x11.rs`, `console.rs`):**
    * Defines `trait Driver` with methods like `process_events() -> Result<Vec<BackendEvent>>`, `get_font_dimensions`, `get_dimensions_cells`, and crucially `execute_commands(commands: Vec<RenderCommand>) -> Result<()`.
    * Defines `enum BackendEvent` with platform-agnostic variants (e.g., for key events: `Key { symbol: KeySymbol, modifiers: Modifiers, text: Option<String> }`).
    * Defines `enum RenderCommand` (the Lingua Franca for rendering).
    * `x11::XDriver`, `console::ConsoleDriver`: Concrete `Driver` implementations, responsible for translating to/from their respective platform specifics and the abstract `BackendEvent`/`RenderCommand` types.
* **`renderer` Module (`Renderer` struct):**
    * **Backend-agnostic.**
    * `prepare_render_commands(&mut self, term: &mut dyn TerminalInterface) -> Vec<RenderCommand>`:
        * Calls `let snapshot = term.get_render_snapshot();`.
        * Iterates `snapshot.lines`. For each line where `is_dirty` is true, it processes the line's cell data.
        * Generates drawing-related `RenderCommand`s (e.g., `ClearAll` if first frame, `DrawTextRun`, `FillRect`) based on the snapshot.
        * Generates `RenderCommand`s for cursor drawing if the cursor is visible and its state requires an update based on the snapshot.
        * Returns the `Vec<RenderCommand>`.
* **`os` Module (`pty.rs`, `epoll.rs`):**
    * Provides PTY and event monitoring utilities.
* **`color` Module:**
    * Defines color representations and utilities. `ConcreteColor` (a resolved `Color`) would be used in `RenderCommand`s.

## 4. Data & Control Flow

1.  **PTY Output:** (Same as v1.6)
2.  **User Input (Key):** `Driver` detects platform-specific key event -> Translates to abstract `BackendEvent::Key` -> `AppOrchestrator` calls `driver.process_events()` -> `AppOrchestrator` receives `BackendEvent::Key` -> `AppOrchestrator` calls `term.interpret_input(EmulatorInput::User(...))` -> `EmulatorAction::WritePty(bytes)` returned -> `AppOrchestrator` writes bytes to PTY.
3.  **User Input (Resize):** (Same as v1.6)
4.  **Rendering & Dirty Flag Clearing:** (Same as v1.6, with `Renderer` generating `RenderCommand`s for cursor based on `RenderSnapshot::cursor_state`).

## 5. Benefits of this Architecture

* **Testability:** `TerminalEmulator` is testable. `Renderer` can be tested for correct `RenderCommand` generation. `Driver`s can be tested by feeding them `RenderCommand`s and by simulating platform events to check `BackendEvent` translation.
* **Separation of Concerns:** Extremely clear boundaries. `Renderer` is purely a translator from terminal state to abstract render operations. `Driver`s are purely translators between platform specifics and the abstract `RenderCommand`/`BackendEvent` languages.
* **Maintainability & Extensibility:** Adding new backends means implementing the `Driver` trait (translation logic). Rendering logic changes are confined to `Renderer`. Terminal emulation logic is in `TerminalEmulator`.
* **Clarity:** The "intermediate language" approach for both `RenderCommand` (output) and `BackendEvent` (input) makes the system's interfaces very explicit.
* **Stability:** Avoids complex GPU rendering dependencies.

## 6. Future Considerations

* **Configuration:** A dedicated mechanism for user configuration.
* **Error Handling:** Consistent and robust error propagation. Errors originating from I/O (PTY, Driver) or platform interactions should generally propagate up to the `AppOrchestrator`, which will log them and decide whether to attempt recovery or signal a shutdown. The `TerminalEmulator` itself, as a state machine, should aim to handle all defined `EmulatorInput` variants gracefully, potentially ignoring malformed or unsupported sequences rather than erroring, to maintain robustness.
* **Performance:** Profiling `RenderSnapshot` creation, `RenderCommand` generation, and `Driver` execution/translation. The design prioritizes correctness and clarity; performance optimizations will be guided by profiling after core functionality is stable.
* **Platform Support:** Potential for more `Driver` implementations.
* **`RenderSnapshot` Definition (Refined):**
    ```rust
    // Example structure, to be precisely defined in `term` module.
    pub struct RenderSnapshot {
        pub dimensions: (usize, usize), // cols, rows
        pub lines: Vec<SnapshotLine>,
        pub cursor_state: Option<CursorRenderState>, // Contains info for drawing the cursor
    }

    pub struct SnapshotLine {
        pub is_dirty: bool, // Was this line dirty at the time of snapshot?
        pub cells: Vec<Glyph>, // Full glyph data for the line
    }

    pub struct CursorRenderState { // Information needed by Renderer to generate cursor RenderCommands
        pub x: usize, // Physical x of the cell the cursor is on/starts at
        pub y: usize, // Physical y
        pub shape: CursorShape, // e.g., Block, Underline, Bar
        pub is_visible: bool,
        pub cell_char_underneath: char, // Character in the cell (could be space)
        pub cell_attributes_underneath: Attributes, // Attributes of the cell
    }
    ```
* **`RenderCommand` Definition (Lingua Franca):**
    ```rust
    // Example structure, to be defined in `backends` module.
    // ConcreteColor would be a resolved Color (e.g., an RGB struct or enum variant).
    // AttrFlagsForRender would be a subset of AttrFlags relevant for visual rendering.
    pub enum RenderCommand {
        // Drawing Commands
        ClearAll { bg: ConcreteColor },
        DrawTextRun {
            x: usize, y: usize,
            text: String,
            fg: ConcreteColor, bg: ConcreteColor,
            flags: AttrFlagsForRender,
        },
        FillRect {
            x: usize, y: usize,
            width: usize, height: usize,
            color: ConcreteColor,
        },
        // Display & Platform Operations
        SetCursorVisibility { visible: bool }, // For Driver's native cursor, if any
        SetWindowTitle { title: String },
        RingBell,
        // Frame Control
        PresentFrame, // Signals the end of a frame's commands and to update the display
    }
    ```
* **`BackendEvent` Definition (Abstract Platform Input):**
    ```rust
    // Example structure, to be defined in `backends` module.
    pub enum BackendEvent {
        Key {
            symbol: KeySymbol,
            modifiers: Modifiers,
            text: Option<String>, // Text generated by IME or key press
        },
        Mouse { event_type: MouseEventType, x: usize, y: usize, button: MouseButton, modifiers: Modifiers },
        Resize { width_px: u16, height_px: u16 },
        FocusGained,
        FocusLost,
        CloseRequested,
        // Other platform events as needed
    }

    #[derive(Debug, Clone, Copy, PartialEq, Eq)]
    pub enum KeySymbol {
        Char(char),
        Enter, Backspace, Tab, Escape, Delete, Insert,
        Home, End, PageUp, PageDown,
        UpArrow, DownArrow, LeftArrow, RightArrow,
        F(u8), // F1, F2, ...
        Unknown(u32), // Fallback for unmapped platform-specific codes
    }

    bitflags! {
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Default)]
        pub struct Modifiers: u8 {
            const SHIFT = 1 << 0;
            const CONTROL = 1 << 1;
            const ALT = 1 << 2; // Or Meta
            const SUPER = 1 << 3; // Or Windows/Command key
        }
    }
    // MouseButton, MouseEventType enums would also be defined.
    ```
* **`EmulatorInput::ControlEvent` Definition:**
    ```rust
    // Example, to be defined in `term` module.
    pub enum ControlEvent {
        FrameRendered,
    }
    ```

