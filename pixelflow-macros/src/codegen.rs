//! # Code Generation
//!
//! Emits Rust code from the analyzed AST.
//!
//! ## Architecture: ZST Expression + Let/Var Binding
//!
//! PixelFlow expressions are Copy when all components are ZST (zero-sized types).
//! The coordinate variables X, Y, Z, W are ZST, and so are Var<N> references.
//! This means expressions using Var<N> remain Copy.
//!
//! The solution is a two-layer architecture:
//!
//! 1. **ZST Expression**: Built using coordinate variables (X, Y, Z, W) and Var<N>
//! 2. **Value Struct**: Stores non-ZST captured parameters (f32 values)
//! 3. **Let/Var binding**: Nested Let wrappers extend domain with parameter values
//!
//! ## Let/Var Binding (Peano-Encoded Stack)
//!
//! Parameters are bound using nested `Let::new()` calls that extend the domain:
//! - First param → deepest binding → `Var::<N{n-1}>`
//! - Last param → shallowest binding → `Var::<N0>` (head of stack)
//!
//! This allows **unlimited parameters** (no longer limited to 2).
//!
//! ## Example Transformation
//!
//! ```text
//! // User writes:
//! kernel!(|cx: f32, cy: f32, cz: f32| X - cx + Y - cy + Z - cz)
//!
//! // Becomes:
//! struct __Kernel { cx: f32, cy: f32, cz: f32 }
//!
//! impl Manifold<Field4> for __Kernel {
//!     fn eval(&self, __p: Field4) -> Field {
//!         // ZST expression using Var<N> (Copy!)
//!         let __expr = X - Var::<N2>::new() + Y - Var::<N1>::new() + Z - Var::<N0>::new();
//!         // Nested Let bindings extend domain with parameter values
//!         Let::new(self.cx,
//!           Let::new(self.cy,
//!             Let::new(self.cz,
//!               __expr))).eval(__p)
//!     }
//! }
//! ```

use crate::annotate::{
    annotate, AnnotatedExpr, AnnotatedStmt, AnnotationCtx, CollectedLiteral,
};
use crate::ast::{BinaryOp, ParamKind, UnaryOp};
use crate::sema::AnalyzedKernel;
use crate::symbol::SymbolKind;
use proc_macro2::TokenStream;
use quote::{ToTokens, format_ident, quote};
use std::collections::HashMap;

// Peano type names (N0, N1, ..., N255) are now generated dynamically.
// This removes the hardcoded limit. Types are generated by generate_peano_types!
// macro in pixelflow-core and referenced here using format!("N{}", idx).

/// Emit Rust code for an analyzed kernel.
pub fn emit(analyzed: AnalyzedKernel) -> TokenStream {
    let mut emitter = CodeEmitter::new(&analyzed);
    emitter.emit_kernel()
}

/// The code emitter state.
struct CodeEmitter<'a> {
    analyzed: &'a AnalyzedKernel,
    /// Maps parameter names to their Peano index for Var<N> access.
    /// First param → highest index (deepest in stack), last param → N0 (head).
    param_indices: HashMap<String, usize>,
    /// Maps manifold parameter names to their generic type index (M0, M1, ...).
    manifold_indices: HashMap<String, usize>,
    /// Whether we're generating for a Jet domain (Jet2, Jet3).
    /// If true, f32 literals must be wrapped as constant jets.
    use_jet_wrapper: bool,
    /// Collected literals from annotation pass (for Let bindings in Jet mode).
    collected_literals: Vec<CollectedLiteral>,
}

impl<'a> CodeEmitter<'a> {
    fn new(analyzed: &'a AnalyzedKernel) -> Self {
        // Compute Peano indices for ALL parameters (both scalar and manifold).
        // With n parameters, first param is at index n-1, last param is at index 0.
        let n = analyzed.def.params.len();
        let mut param_indices = HashMap::new();
        for (i, param) in analyzed.def.params.iter().enumerate() {
            // First param (i=0) gets highest index (n-1), last param gets 0
            let peano_idx = n - 1 - i;
            param_indices.insert(param.name.to_string(), peano_idx);
        }

        // Compute generic type indices for manifold parameters (M0, M1, ...).
        // These are numbered in declaration order.
        let mut manifold_indices = HashMap::new();
        let mut manifold_count = 0;
        for param in &analyzed.def.params {
            if matches!(param.kind, ParamKind::Manifold) {
                manifold_indices.insert(param.name.to_string(), manifold_count);
                manifold_count += 1;
            }
        }

        // Determine if we need to wrap literals for Jet domains
        let use_jet_wrapper = match &analyzed.def.return_ty {
            Some(ty) => {
                let ty_str = quote! { #ty }.to_string();
                ty_str.contains("Jet3") || ty_str.contains("Jet2")
            }
            None => false,
        };

        CodeEmitter {
            analyzed,
            param_indices,
            manifold_indices,
            use_jet_wrapper,
            collected_literals: Vec::new(), // Populated during emit_kernel
        }
    }

    /// Emit the complete kernel definition.
    fn emit_kernel(&mut self) -> TokenStream {
        // Dispatch based on whether this is a named or anonymous kernel
        if let Some(ref decl) = self.analyzed.def.struct_decl {
            self.emit_named_kernel(decl.visibility.clone(), decl.name.clone())
        } else {
            self.emit_closure_kernel()
        }
    }

    /// Emit an anonymous kernel as a closure returning WithContext.
    ///
    /// This allows natural environment capture via Rust's closure semantics.
    ///
    /// Output pattern:
    /// ```ignore
    /// move |cx: f32, cy: f32| {
    ///     use ::pixelflow_core::{X, Y, Z, W, WithContext, CtxVar, ...};
    ///     let __expr = { X - CtxVar::<N0>::new() };
    ///     WithContext::new((cx, cy), __expr)
    /// }
    /// ```
    fn emit_closure_kernel(&mut self) -> TokenStream {
        let params = &self.analyzed.def.params;

        // Run annotation pass to collect literals and assign Var indices
        let annotation_ctx = AnnotationCtx::new();
        let (annotated_body, _, collected_literals) = annotate(&self.analyzed.def.body, annotation_ctx);
        self.collected_literals = collected_literals;

        // Only adjust param indices for literals if we're in Jet mode
        if self.use_jet_wrapper {
            let literal_count = self.collected_literals.len();
            for (_, idx) in self.param_indices.iter_mut() {
                *idx += literal_count;
            }
        }

        // Transform and emit the body as a ZST expression
        let body = self.emit_annotated_expr(&annotated_body);

        // Generate the Peano type imports needed
        let peano_imports = self.emit_peano_imports();

        // Generate closure parameters with types
        let closure_params: Vec<TokenStream> = params
            .iter()
            .map(|p| {
                let name = &p.name;
                match &p.kind {
                    ParamKind::Scalar(ty) => quote! { #name: #ty },
                    ParamKind::Manifold => quote! { #name },
                }
            })
            .collect();

        // Build the context tuple for WithContext
        // Parameters are ordered by their Peano index
        let n = params.len();
        if n == 0 {
            // No parameters - but may have literals in Jet mode
            if self.use_jet_wrapper && !self.collected_literals.is_empty() {
                // Jet mode with literals: put them in context tuple
                let scalar_type = match &self.analyzed.def.return_ty {
                    Some(ty) => {
                        let ty_str = quote! { #ty }.to_string();
                        if ty_str.contains("Jet3") {
                            quote! { ::pixelflow_core::jet::Jet3 }
                        } else if ty_str.contains("Jet2") {
                            quote! { ::pixelflow_core::jet::Jet2 }
                        } else {
                            quote! { ::pixelflow_core::Field }
                        }
                    }
                    None => quote! { ::pixelflow_core::Field },
                };

                // Build tuple of literal values sorted by index
                let mut indexed_lits: Vec<(usize, TokenStream)> = Vec::new();
                for collected in self.collected_literals.iter() {
                    let lit = &collected.lit;
                    let lit_value = quote! { #scalar_type::constant(::pixelflow_core::Field::from(#lit)) };
                    indexed_lits.push((collected.index, lit_value));
                }
                indexed_lits.sort_by_key(|(idx, _)| *idx);
                let lit_values: Vec<_> = indexed_lits.into_iter().map(|(_, val)| val).collect();

                let tuple_expr = if lit_values.len() == 1 {
                    let val = &lit_values[0];
                    quote! { (#val,) }
                } else {
                    quote! { (#(#lit_values),*) }
                };

                quote! {
                    || {
                        use ::pixelflow_core::{X, Y, Z, W, ManifoldExt, ManifoldCompat, Manifold, Let, Var, WithContext, CtxVar, GradientMag2D, GradientMag3D, Antialias2D, Antialias3D, Curvature2D, Normalized2D, Normalized3D, V, DX, DY, DZ, DXX, DXY, DYY};
                        #peano_imports

                        let __expr = { #body };
                        WithContext::new(#tuple_expr, __expr)
                    }
                }
            } else {
                // No parameters, no Jet literals - simple case
                quote! {
                    || {
                        use ::pixelflow_core::{X, Y, Z, W, ManifoldExt, ManifoldCompat, Manifold, Let, Var, WithContext, CtxVar, GradientMag2D, GradientMag3D, Antialias2D, Antialias3D, Curvature2D, Normalized2D, Normalized3D, V, DX, DY, DZ, DXX, DXY, DYY};
                        #peano_imports

                        let __expr = { #body };
                        WithContext::new((), __expr)
                    }
                }
            }
        } else {
            // Determine scalar type for Jet mode
            let scalar_type = match &self.analyzed.def.return_ty {
                Some(ty) => {
                    let ty_str = quote! { #ty }.to_string();
                    if ty_str.contains("Jet3") {
                        Some(quote! { ::pixelflow_core::jet::Jet3 })
                    } else if ty_str.contains("Jet2") {
                        Some(quote! { ::pixelflow_core::jet::Jet2 })
                    } else {
                        None
                    }
                }
                None => None,
            };

            // Build context tuple with BOTH params AND literals (for Jet mode)
            // This keeps the expression tree ZST (using CtxVar for everything)
            //
            // Layout: (literal_0, literal_1, ..., param_at_lowest_idx, param_at_next_idx, ...)
            // Literals get indices 0..literal_count-1
            // Params get indices literal_count..literal_count+param_count-1
            let mut indexed_values: Vec<(usize, TokenStream)> = Vec::new();

            // Add params to indexed values
            for param in params.iter() {
                let idx = self.param_indices[&param.name.to_string()];
                let param_name = &param.name;
                let param_value = match (&param.kind, &scalar_type) {
                    (ParamKind::Scalar(_), Some(scalar_ty)) => {
                        // Jet mode: wrap scalar as constant
                        quote! { #scalar_ty::constant(::pixelflow_core::Field::from(#param_name)) }
                    }
                    _ => {
                        // Non-Jet mode or manifold param: use value directly
                        quote! { #param_name }
                    }
                };
                indexed_values.push((idx, param_value));
            }

            // Add literals to indexed values (Jet mode only)
            if self.use_jet_wrapper {
                let scalar_ty = scalar_type.clone().unwrap_or(quote! { ::pixelflow_core::Field });
                for collected in self.collected_literals.iter() {
                    let lit = &collected.lit;
                    // Literals go at indices 0..literal_count-1 (using collection index)
                    let lit_value = quote! { #scalar_ty::constant(::pixelflow_core::Field::from(#lit)) };
                    indexed_values.push((collected.index, lit_value));
                }
            }

            // Sort by index to get correct tuple order
            indexed_values.sort_by_key(|(idx, _)| *idx);
            let tuple_values: Vec<_> = indexed_values.into_iter().map(|(_, val)| val).collect();

            // Generate the tuple expression (handle 1-element tuple specially)
            let tuple_expr = if tuple_values.len() == 1 {
                let val = &tuple_values[0];
                quote! { (#val,) }
            } else {
                quote! { (#(#tuple_values),*) }
            };

            // No Let bindings needed - everything is in the flat context tuple
            quote! {
                move |#(#closure_params),*| {
                    use ::pixelflow_core::{X, Y, Z, W, ManifoldExt, ManifoldCompat, Manifold, Let, Var, WithContext, CtxVar, GradientMag2D, GradientMag3D, Antialias2D, Antialias3D, Curvature2D, Normalized2D, Normalized3D, V, DX, DY, DZ, DXX, DXY, DYY};
                    #peano_imports

                    let __expr = { #body };
                    WithContext::new(#tuple_expr, __expr)
                }
            }
        }
    }

    /// Emit a named kernel as a struct with Manifold impl.
    ///
    /// This creates a user-named struct that can be used in struct fields.
    /// Includes a `new` constructor for ergonomic instantiation.
    fn emit_named_kernel(&mut self, visibility: syn::Visibility, name: syn::Ident) -> TokenStream {
        let params = &self.analyzed.def.params;

        // Count manifold parameters for generic type generation
        let manifold_count = self.manifold_indices.len();

        // Generate generic type parameter names (M0, M1, ...)
        let generic_names: Vec<syn::Ident> = (0..manifold_count)
            .map(|i| format_ident!("M{}", i))
            .collect();

        // Generate struct fields with pub visibility
        let struct_fields: Vec<TokenStream> = params
            .iter()
            .map(|p| {
                let field_name = &p.name;
                match &p.kind {
                    ParamKind::Scalar(ty) => quote! { pub #field_name: #ty },
                    ParamKind::Manifold => {
                        let idx = self.manifold_indices[&field_name.to_string()];
                        let generic_name = &generic_names[idx];
                        quote! { pub #field_name: #generic_name }
                    }
                }
            })
            .collect();

        // Generate struct field names for construction
        let field_names: Vec<_> = params.iter().map(|p| &p.name).collect();

        // Generate constructor parameters
        let constructor_params: Vec<TokenStream> = params
            .iter()
            .map(|p| {
                let field_name = &p.name;
                match &p.kind {
                    ParamKind::Scalar(ty) => quote! { #field_name: #ty },
                    ParamKind::Manifold => {
                        let idx = self.manifold_indices[&field_name.to_string()];
                        let generic_name = &generic_names[idx];
                        quote! { #field_name: #generic_name }
                    }
                }
            })
            .collect();

        // Run annotation pass to collect literals and assign Var indices
        let annotation_ctx = AnnotationCtx::new();
        let (annotated_body, _, collected_literals) = annotate(&self.analyzed.def.body, annotation_ctx);
        self.collected_literals = collected_literals;

        // Only adjust param indices for literals if we're in Jet mode
        if self.use_jet_wrapper {
            let literal_count = self.collected_literals.len();
            for (_, idx) in self.param_indices.iter_mut() {
                *idx += literal_count;
            }
        }

        // Transform and emit the body as a ZST expression
        let body = self.emit_annotated_expr(&annotated_body);

        // Generate the Peano type imports needed
        let peano_imports = self.emit_peano_imports();

        // Determine output type and domain type
        let (output_type, domain_type, scalar_type) = match &self.analyzed.def.return_ty {
            Some(ty) => {
                let ty_str = quote! { #ty }.to_string();
                if ty_str.contains("Jet3") {
                    (
                        quote! { #ty },
                        quote! { (::pixelflow_core::jet::Jet3, ::pixelflow_core::jet::Jet3, ::pixelflow_core::jet::Jet3, ::pixelflow_core::jet::Jet3) },
                        quote! { ::pixelflow_core::jet::Jet3 },
                    )
                } else if ty_str.contains("Jet2") {
                    (
                        quote! { #ty },
                        quote! { (::pixelflow_core::jet::Jet2, ::pixelflow_core::jet::Jet2, ::pixelflow_core::jet::Jet2, ::pixelflow_core::jet::Jet2) },
                        quote! { ::pixelflow_core::jet::Jet2 },
                    )
                } else {
                    (
                        quote! { #ty },
                        quote! { (::pixelflow_core::Field, ::pixelflow_core::Field, ::pixelflow_core::Field, ::pixelflow_core::Field) },
                        quote! { ::pixelflow_core::Field },
                    )
                }
            }
            None => (
                quote! { ::pixelflow_core::Field },
                quote! { (::pixelflow_core::Field, ::pixelflow_core::Field, ::pixelflow_core::Field, ::pixelflow_core::Field) },
                quote! { ::pixelflow_core::Field },
            ),
        };

        // Generate the binding
        let (manifold_eval_stmts, at_binding) = self.emit_unified_binding();

        // Handle different parameter configurations
        if params.is_empty() {
            // No parameters - unit struct
            quote! {
                type __Domain = #domain_type;
                type __Scalar = #scalar_type;

                #[derive(Clone, Copy)]
                #visibility struct #name;

                impl #name {
                    pub fn new() -> Self { Self }
                }

                impl Default for #name {
                    fn default() -> Self { Self::new() }
                }

                impl ::pixelflow_core::Manifold<__Domain> for #name {
                    type Output = #output_type;

                    #[inline(always)]
                    fn eval(&self, __p: __Domain) -> #output_type {
                        use ::pixelflow_core::{X, Y, Z, W, ManifoldExt, ManifoldCompat, Manifold, Let, Var, WithContext, CtxVar, GradientMag2D, GradientMag3D, Antialias2D, Antialias3D, Curvature2D, Normalized2D, Normalized3D, V, DX, DY, DZ, DXX, DXY, DYY};
                        #peano_imports

                        let __expr = { #body };
                        #at_binding
                    }
                }
            }
        } else if manifold_count == 0 && params.len() == 1 {
            // Single scalar parameter - derive Copy
            quote! {
                type __Domain = #domain_type;
                type __Scalar = #scalar_type;

                #[derive(Clone, Copy)]
                #visibility struct #name { #(#struct_fields),* }

                impl #name {
                    pub fn new(#(#constructor_params),*) -> Self {
                        Self { #(#field_names),* }
                    }
                }

                impl ::pixelflow_core::Manifold<__Domain> for #name {
                    type Output = #output_type;

                    #[inline(always)]
                    fn eval(&self, __p: __Domain) -> #output_type {
                        use ::pixelflow_core::{X, Y, Z, W, ManifoldExt, ManifoldCompat, Manifold, Let, Var, WithContext, CtxVar, GradientMag2D, GradientMag3D, Antialias2D, Antialias3D, Curvature2D, Normalized2D, Normalized3D, V, DX, DY, DZ, DXX, DXY, DYY};
                        #peano_imports

                        let __expr = { #body };
                        #at_binding
                    }
                }
            }
        } else if manifold_count == 0 {
            // Multiple scalar parameters - Clone but not Copy
            quote! {
                type __Domain = #domain_type;
                type __Scalar = #scalar_type;

                #[derive(Clone)]
                #visibility struct #name { #(#struct_fields),* }

                impl #name {
                    pub fn new(#(#constructor_params),*) -> Self {
                        Self { #(#field_names),* }
                    }
                }

                impl ::pixelflow_core::Manifold<__Domain> for #name {
                    type Output = #output_type;

                    #[inline(always)]
                    fn eval(&self, __p: __Domain) -> #output_type {
                        use ::pixelflow_core::{X, Y, Z, W, ManifoldExt, ManifoldCompat, Manifold, Let, Var, WithContext, CtxVar, GradientMag2D, GradientMag3D, Antialias2D, Antialias3D, Curvature2D, Normalized2D, Normalized3D, V, DX, DY, DZ, DXX, DXY, DYY};
                        #peano_imports

                        let __expr = { #body };
                        #at_binding
                    }
                }
            }
        } else if manifold_count == 1 && params.len() == 1 {
            // Single manifold parameter - conditional Copy when M0: Copy
            let has_return_type = self.analyzed.def.return_ty.is_some();

            if has_return_type {
                let trait_bounds: Vec<TokenStream> = generic_names
                    .iter()
                    .map(|g| {
                        quote! { #g: ::pixelflow_core::Manifold<__Domain, Output = __Scalar> }
                    })
                    .collect();

                quote! {
                    type __Domain = #domain_type;
                    type __Scalar = #scalar_type;

                    #visibility struct #name<#(#generic_names),*> { #(#struct_fields),* }

                    impl<#(#generic_names: Clone),*> Clone for #name<#(#generic_names),*> {
                        fn clone(&self) -> Self {
                            Self { #(#field_names: self.#field_names.clone()),* }
                        }
                    }

                    impl<#(#generic_names: Copy),*> Copy for #name<#(#generic_names),*> {}

                    impl<#(#generic_names),*> #name<#(#generic_names),*> {
                        pub fn new(#(#constructor_params),*) -> Self {
                            Self { #(#field_names),* }
                        }
                    }

                    impl<#(#generic_names),*> ::pixelflow_core::Manifold<__Domain> for #name<#(#generic_names),*>
                    where
                        #(#trait_bounds),*
                    {
                        type Output = #output_type;

                        #[inline(always)]
                        fn eval(&self, __p: __Domain) -> #output_type {
                            use ::pixelflow_core::{X, Y, Z, W, ManifoldExt, ManifoldCompat, Manifold, Let, Var, WithContext, CtxVar, GradientMag2D, GradientMag3D, Antialias2D, Antialias3D, Curvature2D, Normalized2D, Normalized3D, V, DX, DY, DZ, DXX, DXY, DYY};
                            #peano_imports

                            #manifold_eval_stmts

                            let __expr = { #body };
                            #at_binding
                        }
                    }
                }
            } else {
                // No return type → generic domain P
                quote! {
                    #visibility struct #name<#(#generic_names),*> { #(#struct_fields),* }

                    impl<#(#generic_names: Clone),*> Clone for #name<#(#generic_names),*> {
                        fn clone(&self) -> Self {
                            Self { #(#field_names: self.#field_names.clone()),* }
                        }
                    }

                    impl<#(#generic_names: Copy),*> Copy for #name<#(#generic_names),*> {}

                    impl<#(#generic_names),*> #name<#(#generic_names),*> {
                        pub fn new(#(#constructor_params),*) -> Self {
                            Self { #(#field_names),* }
                        }
                    }

                    impl<#(#generic_names),*, __P> ::pixelflow_core::Manifold<__P> for #name<#(#generic_names),*>
                    where
                        __P: Copy + Send + Sync + ::pixelflow_core::Spatial,
                        #(#generic_names: ::pixelflow_core::Manifold<__P>),*,
                        #(<#generic_names as ::pixelflow_core::Manifold<__P>>::Output: Copy + Send + Sync),*,
                    {
                        type Output = ::pixelflow_core::Field;

                        #[inline(always)]
                        fn eval(&self, __p: __P) -> ::pixelflow_core::Field {
                            use ::pixelflow_core::{X, Y, Z, W, ManifoldExt, ManifoldCompat, Manifold, Let, Var, WithContext, CtxVar, GradientMag2D, GradientMag3D, Antialias2D, Antialias3D, Curvature2D, Normalized2D, Normalized3D, V, DX, DY, DZ, DXX, DXY, DYY};
                            #peano_imports

                            #manifold_eval_stmts

                            let __expr = { #body };
                            #at_binding
                        }
                    }
                }
            }
        } else {
            // Multiple manifold/mixed parameters
            let has_return_type = self.analyzed.def.return_ty.is_some();

            if has_return_type {
                let trait_bounds: Vec<TokenStream> = generic_names
                    .iter()
                    .map(|g| {
                        quote! { #g: ::pixelflow_core::Manifold<__Domain, Output = __Scalar> }
                    })
                    .collect();

                quote! {
                    type __Domain = #domain_type;
                    type __Scalar = #scalar_type;

                    #visibility struct #name<#(#generic_names),*> { #(#struct_fields),* }

                    impl<#(#generic_names: Clone),*> Clone for #name<#(#generic_names),*> {
                        fn clone(&self) -> Self {
                            Self { #(#field_names: self.#field_names.clone()),* }
                        }
                    }

                    impl<#(#generic_names),*> #name<#(#generic_names),*> {
                        pub fn new(#(#constructor_params),*) -> Self {
                            Self { #(#field_names),* }
                        }
                    }

                    impl<#(#generic_names),*> ::pixelflow_core::Manifold<__Domain> for #name<#(#generic_names),*>
                    where
                        #(#trait_bounds),*
                    {
                        type Output = #output_type;

                        #[inline(always)]
                        fn eval(&self, __p: __Domain) -> #output_type {
                            use ::pixelflow_core::{X, Y, Z, W, ManifoldExt, ManifoldCompat, Manifold, Let, Var, WithContext, CtxVar, GradientMag2D, GradientMag3D, Antialias2D, Antialias3D, Curvature2D, Normalized2D, Normalized3D, V, DX, DY, DZ, DXX, DXY, DYY};
                            #peano_imports

                            #manifold_eval_stmts

                            let __expr = { #body };
                            #at_binding
                        }
                    }
                }
            } else {
                // No return type → generic domain P
                quote! {
                    #visibility struct #name<#(#generic_names),*> { #(#struct_fields),* }

                    impl<#(#generic_names: Clone),*> Clone for #name<#(#generic_names),*> {
                        fn clone(&self) -> Self {
                            Self { #(#field_names: self.#field_names.clone()),* }
                        }
                    }

                    impl<#(#generic_names),*> #name<#(#generic_names),*> {
                        pub fn new(#(#constructor_params),*) -> Self {
                            Self { #(#field_names),* }
                        }
                    }

                    impl<#(#generic_names),*, __P> ::pixelflow_core::Manifold<__P> for #name<#(#generic_names),*>
                    where
                        __P: Copy + Send + Sync + ::pixelflow_core::Spatial,
                        #(#generic_names: ::pixelflow_core::Manifold<__P, Output = ::pixelflow_core::Field>),*,
                    {
                        type Output = ::pixelflow_core::Field;

                        #[inline(always)]
                        fn eval(&self, __p: __P) -> ::pixelflow_core::Field {
                            use ::pixelflow_core::{X, Y, Z, W, ManifoldExt, ManifoldCompat, Manifold, Let, Var, WithContext, CtxVar, GradientMag2D, GradientMag3D, Antialias2D, Antialias3D, Curvature2D, Normalized2D, Normalized3D, V, DX, DY, DZ, DXX, DXY, DYY};
                            #peano_imports

                            #manifold_eval_stmts

                            let __expr = { #body };
                            #at_binding
                        }
                    }
                }
            }
        }
    }

    /// Emit the Peano type imports needed based on parameter + literal count.
    fn emit_peano_imports(&self) -> TokenStream {
        // In Jet mode: need types for params + literals
        // In non-Jet mode: only need types for params (literals are inlined)
        let total = if self.use_jet_wrapper {
            self.analyzed.def.params.len() + self.collected_literals.len()
        } else {
            self.analyzed.def.params.len()
        };

        if total == 0 {
            return quote! {};
        }

        // Import N0..N{total-1}
        let imports: Vec<TokenStream> = (0..total)
            .map(|i| {
                let name_str = format!("N{}", i);
                let name = syn::Ident::new(&name_str, proc_macro2::Span::call_site());
                quote! { #name }
            })
            .collect();

        quote! { use ::pixelflow_core::binding::{ #(#imports),* }; }
    }

    /// Emit unified WithContext/CtxVar binding for params (and Let for literals).
    ///
    /// Returns two things:
    /// 1. Statements for pre-evaluating manifold params (when mixed with scalars)
    /// 2. WithContext::new(tuple, body) for params, wrapped in Let for literals
    ///
    /// NEW APPROACH: Uses flat WithContext tuple instead of nested Let for parameters.
    /// This avoids trait solver explosion for >4 parameters.
    ///
    /// Binding order:
    /// - Parameters → WithContext flat tuple (CtxVar<N0>, CtxVar<N1>, ...)
    /// - Literals (Jet mode only) → nested Let (wraps the WithContext)
    ///
    /// ## Mixed Param Handling
    ///
    /// When manifold params are mixed with scalar params, we must eagerly evaluate
    /// the manifold params to get concrete `__Scalar` values for type unification.
    fn emit_unified_binding(&self) -> (TokenStream, TokenStream) {
        let params = &self.analyzed.def.params;

        if params.is_empty() && self.collected_literals.is_empty() {
            // No bindings needed - evaluate expression directly
            return (quote! {}, quote! { __expr.eval(__p) });
        }

        // Determine if we need to pre-evaluate manifold params
        let manifold_count = self.manifold_indices.len();
        let has_scalar_params = params.iter().any(|p| matches!(p.kind, ParamKind::Scalar(_)));
        let needs_pre_eval = manifold_count > 0 && (manifold_count > 1 || has_scalar_params);

        // Determine the scalar type to use for pre-evaluation
        let has_return_type = self.analyzed.def.return_ty.is_some();
        let scalar_type_token = if has_return_type {
            quote! { __Scalar }
        } else {
            quote! { ::pixelflow_core::Field }
        };

        // Pre-evaluate manifolds to get concrete scalar values
        let mut pre_eval_stmts = Vec::new();
        if needs_pre_eval {
            for param in params.iter() {
                if matches!(param.kind, ParamKind::Manifold) {
                    let name = &param.name;
                    let eval_name = syn::Ident::new(
                        &format!("__eval_{}", name),
                        proc_macro2::Span::call_site(),
                    );
                    pre_eval_stmts.push(quote! {
                        let #eval_name: #scalar_type_token = self.#name.eval(__p);
                    });
                }
            }
        }

        // Build the parameter binding using WithContext for flat tuple approach
        let result = if params.is_empty() {
            // No params, just the expression
            quote! { __expr }
        } else {
            // Build tuple of param values ordered by index
            // Index 0 goes to tuple position 0, index 1 to position 1, etc.
            let _n = params.len();
            let mut indexed_params: Vec<(usize, TokenStream)> = Vec::new();

            for param in params.iter() {
                let name = &param.name;
                let idx = self.param_indices[&name.to_string()];

                let param_value = match &param.kind {
                    ParamKind::Manifold => {
                        if needs_pre_eval {
                            // Use pre-evaluated value for type unification
                            let eval_name = syn::Ident::new(
                                &format!("__eval_{}", name),
                                proc_macro2::Span::call_site(),
                            );
                            quote! { #eval_name }
                        } else {
                            // Single manifold param without scalars - pass reference
                            quote! { &self.#name }
                        }
                    }
                    ParamKind::Scalar(_) => {
                        // For Jet domains, wrap f32 params as constant jets
                        if self.use_jet_wrapper {
                            quote! { __Scalar::constant(::pixelflow_core::Field::from(self.#name)) }
                        } else if needs_pre_eval {
                            // Mixed with manifolds: wrap scalar as Field
                            quote! { #scalar_type_token::from(self.#name) }
                        } else {
                            quote! { self.#name }
                        }
                    }
                };

                indexed_params.push((idx, param_value));
            }

            // Sort by index to get correct tuple order
            indexed_params.sort_by_key(|(idx, _)| *idx);
            let param_values: Vec<_> = indexed_params.into_iter().map(|(_, val)| val).collect();

            // Generate the WithContext tuple
            // CRITICAL: For 1-element tuples, we need a trailing comma: (value,)
            // Without it, Rust interprets (value) as just parentheses, not a tuple!
            if param_values.len() == 1 {
                let val = &param_values[0];
                quote! {
                    WithContext::new((#val,), __expr)
                }
            } else {
                quote! {
                    WithContext::new((#(#param_values),*), __expr)
                }
            }
        };

        // Wrap in Let bindings for literals (Jet mode only)
        let result = if self.use_jet_wrapper && !self.collected_literals.is_empty() {
            let mut wrapped = result;
            // Wrap literals (innermost - reversed so last literal is innermost)
            for collected in self.collected_literals.iter().rev() {
                let lit = &collected.lit;
                let lit_value = quote! { __Scalar::constant(::pixelflow_core::Field::from(#lit)) };
                wrapped = quote! {
                    Let::new(#lit_value, #wrapped)
                };
            }
            wrapped
        } else {
            result
        };

        // Evaluate the expression
        let at_binding = quote! { #result.eval(__p) };

        // Return pre-eval statements and the binding
        let stmts = if pre_eval_stmts.is_empty() {
            quote! {}
        } else {
            quote! { #(#pre_eval_stmts)* }
        };
        (stmts, at_binding)
    }

    /// Emit code for an annotated expression (pure, no mutation).
    ///
    /// Literals with var_index become Var<N> references.
    /// This is the clean functional version that works with the annotation pass.
    fn emit_annotated_expr(&self, expr: &AnnotatedExpr) -> TokenStream {
        match expr {
            AnnotatedExpr::Ident(ident_expr) => {
                let name = &ident_expr.name;
                let name_str = name.to_string();

                match self.analyzed.symbols.lookup(&name_str) {
                    Some(symbol) => match symbol.kind {
                        SymbolKind::Intrinsic => {
                            // Intrinsics (X, Y, Z, W) emitted as-is
                            quote! { #name }
                        }
                        SymbolKind::Parameter | SymbolKind::ManifoldParam => {
                            // Both scalar and manifold parameters become CtxVar::<N{index}>::new()
                            // (switched from Var to CtxVar for flat WithContext tuple approach)
                            if let Some(&idx) = self.param_indices.get(&name_str) {
                                if idx < 256 {
                                    let peano_name_str = format!("N{}", idx);
                                    let peano_name = syn::Ident::new(
                                        &peano_name_str,
                                        proc_macro2::Span::call_site(),
                                    );
                                    quote! { CtxVar::<#peano_name>::new() }
                                } else {
                                    let err_msg = format!(
                                        "kernel! supports max 256 bindings, found index {}",
                                        idx
                                    );
                                    quote! { compile_error!(#err_msg) }
                                }
                            } else {
                                quote! { #name }
                            }
                        }
                        SymbolKind::Local => {
                            // Locals emitted as-is
                            quote! { #name }
                        }
                    },
                    None => {
                        // Unknown - emit as-is
                        quote! { #name }
                    }
                }
            }

            AnnotatedExpr::Literal(lit) => {
                if self.use_jet_wrapper {
                    // Jet mode: literals are in context tuple, emit as CtxVar reference
                    if let Some(var_idx) = lit.var_index {
                        // Literals go at indices 0..literal_count-1 in the context tuple
                        // Use var_index directly (no reversal - flat tuple, not Let stack)
                        if var_idx < 256 {
                            let peano_name_str = format!("N{}", var_idx);
                            let peano_name = syn::Ident::new(
                                &peano_name_str,
                                proc_macro2::Span::call_site(),
                            );
                            quote! { CtxVar::<#peano_name>::new() }
                        } else {
                            let err_msg = format!(
                                "kernel! supports max 256 bindings, found index {}",
                                var_idx
                            );
                            quote! { compile_error!(#err_msg) }
                        }
                    } else {
                        // Shouldn't happen in Jet mode, but fallback to direct emission
                        let l = &lit.lit;
                        quote! { __Scalar::constant(::pixelflow_core::Field::from(#l)) }
                    }
                } else {
                    // Non-Jet mode: emit literal directly (no context binding needed)
                    let l = &lit.lit;
                    quote! { #l }
                }
            }

            AnnotatedExpr::Binary(binary) => {
                let lhs = self.emit_annotated_expr(&binary.lhs);
                let rhs = self.emit_annotated_expr(&binary.rhs);

                match binary.op {
                    BinaryOp::Add => quote! { #lhs + #rhs },
                    BinaryOp::Sub => quote! { #lhs - #rhs },
                    BinaryOp::Mul => quote! { #lhs * #rhs },
                    BinaryOp::Div => quote! { #lhs / #rhs },
                    BinaryOp::Rem => quote! { #lhs % #rhs },
                    BinaryOp::Lt => quote! { #lhs.lt(#rhs) },
                    BinaryOp::Le => quote! { #lhs.le(#rhs) },
                    BinaryOp::Gt => quote! { #lhs.gt(#rhs) },
                    BinaryOp::Ge => quote! { #lhs.ge(#rhs) },
                    BinaryOp::Eq => quote! { #lhs.eq(#rhs) },
                    BinaryOp::Ne => quote! { #lhs.ne(#rhs) },
                    BinaryOp::BitAnd => quote! { #lhs & #rhs },
                    BinaryOp::BitOr => quote! { #lhs | #rhs },
                }
            }

            AnnotatedExpr::Unary(unary) => {
                let operand = self.emit_annotated_expr(&unary.operand);
                match unary.op {
                    UnaryOp::Neg => quote! { #operand.neg() },
                    UnaryOp::Not => quote! { !#operand },
                }
            }

            AnnotatedExpr::MethodCall(call) => {
                let receiver = self.emit_annotated_expr(&call.receiver);
                let method = &call.method;
                let args: Vec<TokenStream> = call.args.iter()
                    .map(|a| self.emit_annotated_expr(a))
                    .collect();

                if args.is_empty() {
                    quote! { #receiver.#method() }
                } else {
                    quote! { #receiver.#method(#(#args),*) }
                }
            }

            AnnotatedExpr::Call(call) => {
                // Free function call: V(m), DX(expr), etc.
                // Emit with transformed arguments (manifold params become Var<N>)
                let func = &call.func;
                let args: Vec<TokenStream> = call.args.iter()
                    .map(|a| self.emit_annotated_expr(a))
                    .collect();

                if args.is_empty() {
                    quote! { #func() }
                } else {
                    quote! { #func(#(#args),*) }
                }
            }

            AnnotatedExpr::Block(block) => {
                let stmts: Vec<TokenStream> = block.stmts.iter()
                    .map(|s| self.emit_annotated_stmt(s))
                    .collect();

                let final_expr = block.expr.as_ref().map(|e| self.emit_annotated_expr(e));

                match final_expr {
                    Some(expr) => quote! {
                        {
                            #(#stmts)*
                            #expr
                        }
                    },
                    None => quote! {
                        {
                            #(#stmts)*
                        }
                    },
                }
            }

            AnnotatedExpr::Paren(inner) => {
                let inner_code = self.emit_annotated_expr(inner);
                quote! { (#inner_code) }
            }

            AnnotatedExpr::Verbatim(syn_expr) => {
                syn_expr.to_token_stream()
            }
        }
    }

    fn emit_annotated_stmt(&self, stmt: &AnnotatedStmt) -> TokenStream {
        match stmt {
            AnnotatedStmt::Let(let_stmt) => {
                let name = &let_stmt.name;
                let init = self.emit_annotated_expr(&let_stmt.init);

                match &let_stmt.ty {
                    Some(ty) => quote! { let #name: #ty = #init; },
                    None => quote! { let #name = #init; },
                }
            }
            AnnotatedStmt::Expr(expr) => {
                let code = self.emit_annotated_expr(expr);
                quote! { #code; }
            }
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::parse;
    use crate::sema::analyze;
    use quote::quote;

    fn compile(input: TokenStream) -> TokenStream {
        let kernel = parse(input).unwrap();
        let analyzed = analyze(kernel).unwrap();
        emit(analyzed)
    }

    #[test]
    fn emit_simple_kernel() {
        // Anonymous kernel - emits closure returning WithContext
        let input = quote! { |cx: f32| X - cx };
        let output = compile(input);
        let output_str = output.to_string();

        // Should be a closure
        assert!(
            output_str.contains("move | cx : f32 |"),
            "Expected closure, got: {}",
            output_str
        );
        // Should use CtxVar::<N0> for the single parameter
        assert!(
            output_str.contains("CtxVar :: < N0 >"),
            "Expected CtxVar::<N0>, got: {}",
            output_str
        );
        // Should use WithContext
        assert!(
            output_str.contains("WithContext :: new"),
            "Expected WithContext::new, got: {}",
            output_str
        );
    }

    #[test]
    fn emit_two_params() {
        // Anonymous kernel with two params
        let input = quote! { |cx: f32, cy: f32| (X - cx) + (Y - cy) };
        let output = compile(input);
        let output_str = output.to_string();

        // cx → CtxVar::<N1> (first param, highest index)
        // cy → CtxVar::<N0> (second param, head of stack)
        assert!(
            output_str.contains("CtxVar :: < N1 >"),
            "Expected CtxVar::<N1> for cx, got: {}",
            output_str
        );
        assert!(
            output_str.contains("CtxVar :: < N0 >"),
            "Expected CtxVar::<N0> for cy, got: {}",
            output_str
        );
        // Should use WithContext with tuple
        assert!(
            output_str.contains("WithContext :: new ((cy , cx)"),
            "Expected WithContext with tuple, got: {}",
            output_str
        );
    }

    #[test]
    fn emit_three_params() {
        let input = quote! { |a: f32, b: f32, c: f32| a + b + c };
        let output = compile(input);
        let output_str = output.to_string();

        // a → CtxVar::<N2>, b → CtxVar::<N1>, c → CtxVar::<N0>
        assert!(
            output_str.contains("CtxVar :: < N2 >"),
            "Expected CtxVar::<N2> for a"
        );
        assert!(
            output_str.contains("CtxVar :: < N1 >"),
            "Expected CtxVar::<N1> for b"
        );
        assert!(
            output_str.contains("CtxVar :: < N0 >"),
            "Expected CtxVar::<N0> for c"
        );
        // Should import N0, N1, N2
        assert!(output_str.contains("N0"));
        assert!(output_str.contains("N1"));
        assert!(output_str.contains("N2"));
    }

    #[test]
    fn emit_empty_params() {
        // Anonymous kernel with no params
        let input = quote! { || X + Y };
        let output = compile(input);
        let output_str = output.to_string();

        // Should be a closure with empty params
        assert!(
            output_str.contains("||"),
            "Expected no-param closure, got: {}",
            output_str
        );
        // Should use WithContext with unit
        assert!(
            output_str.contains("WithContext :: new (() , __expr)"),
            "Expected WithContext with unit, got: {}",
            output_str
        );
    }

    #[test]
    fn emit_method_calls() {
        let input = quote! { |r: f32| (X * X + Y * Y).sqrt() - r };
        let output = compile(input);
        let output_str = output.to_string();

        // r → CtxVar::<N0>
        assert!(output_str.contains(". sqrt ()"));
        assert!(
            output_str.contains("CtxVar :: < N0 >"),
            "Expected CtxVar::<N0> for r"
        );
    }

    #[test]
    fn emit_manifold_param() {
        // Anonymous kernel with manifold param - still emits closure
        let input = quote! { |inner: kernel, r: f32| inner - r };
        let output = compile(input);
        let output_str = output.to_string();

        // Should be a closure (anonymous kernels always emit closures)
        assert!(
            output_str.contains("move |"),
            "Expected closure, got: {}",
            output_str
        );

        // inner → CtxVar::<N1>, r → CtxVar::<N0>
        assert!(
            output_str.contains("CtxVar :: < N1 >"),
            "Expected CtxVar::<N1> for inner"
        );
        assert!(
            output_str.contains("CtxVar :: < N0 >"),
            "Expected CtxVar::<N0> for r"
        );

        // Should use WithContext
        assert!(
            output_str.contains("WithContext :: new"),
            "Expected WithContext::new, got: {}",
            output_str
        );
    }

    #[test]
    fn emit_multiple_manifold_params() {
        // Anonymous kernel with multiple manifold params
        let input = quote! { |a: kernel, b: kernel| a + b };
        let output = compile(input);
        let output_str = output.to_string();

        // Should be a closure
        assert!(
            output_str.contains("move |"),
            "Expected closure, got: {}",
            output_str
        );

        // Both params become CtxVar references
        assert!(
            output_str.contains("CtxVar :: < N1 >"),
            "Expected CtxVar::<N1> for a"
        );
        assert!(
            output_str.contains("CtxVar :: < N0 >"),
            "Expected CtxVar::<N0> for b"
        );

        // Should use WithContext with tuple
        assert!(
            output_str.contains("WithContext :: new"),
            "Expected WithContext, got: {}",
            output_str
        );
    }

    #[test]
    fn emit_named_kernel() {
        // Named kernel - emits struct with given name
        let input = quote! { pub struct Circle = |cx: f32, cy: f32, r: f32| -> Field {
            let dx = X - cx;
            let dy = Y - cy;
            (dx * dx + dy * dy).sqrt() - r
        }};
        let output = compile(input);
        let output_str = output.to_string();

        // Should have struct named Circle
        assert!(
            output_str.contains("pub struct Circle"),
            "Expected pub struct Circle, got: {}",
            output_str
        );
        // Should have new constructor
        assert!(
            output_str.contains("pub fn new"),
            "Expected new constructor, got: {}",
            output_str
        );
        // Should implement Manifold
        assert!(
            output_str.contains("impl :: pixelflow_core :: Manifold"),
            "Expected Manifold impl, got: {}",
            output_str
        );
    }
}
