//! Orchestrator Actor - processes events and generates snapshots with backpressure.
//!
//! This actor owns the terminal state machine (TerminalEmulator) and processes
//! events from PTY, Vsync, and Platform threads. It uses a two-channel handshake with the Platform
//! to prevent wasted snapshot generation: only generates snapshots when the Platform signals
//! it's ready via the `ready_rx` channel.
//!
//! The PTY thread (EventMonitorActor) owns the AnsiProcessor and sends parsed AnsiCommands,
//! not raw bytes. This allows parallel parsing while the Orchestrator processes frames.

use crate::keys;
use crate::orchestrator::OrchestratorEvent;
use crate::platform::actions::PlatformAction;
use crate::platform::backends::{BackendEvent, MouseButton};
use crate::term::{ControlEvent, EmulatorAction, EmulatorInput, TerminalEmulator, UserInputAction};
use anyhow::{Context, Result};
use log::*;
use std::sync::mpsc::{Receiver, RecvError, SyncSender};
use std::thread::{self, JoinHandle};

/// Arguments for spawning the OrchestratorActor.
pub struct OrchestratorArgs {
    pub ui_rx: Receiver<OrchestratorEvent>,
    pub pty_rx: Receiver<OrchestratorEvent>,
    pub display_action_tx: SyncSender<PlatformAction>,
    pub pty_action_tx: SyncSender<PlatformAction>,
    pub waker: Box<dyn crate::platform::waker::EventLoopWaker>,
}

/// Orchestrator actor that runs in a background thread.
///
/// Receives events from PTY, Vsync, and Platform threads, processes them through the terminal
/// emulator, and sends snapshots to the Platform only when it's ready (backpressure).
pub struct OrchestratorActor {
    thread_handle: Option<JoinHandle<()>>,
}

impl OrchestratorActor {
    /// Spawns the Orchestrator actor in a background thread.
    ///
    /// # Arguments
    ///
    /// * `term_emulator` - The terminal emulator (takes ownership)
    /// * `args` - The arguments required to run the orchestrator loop.
    ///
    /// # Returns
    ///
    /// Returns `Self` (handle to the actor for cleanup)
    pub fn spawn(term_emulator: TerminalEmulator, args: OrchestratorArgs) -> Result<Self> {
        info!("OrchestratorActor: Spawning background thread");

        let thread_handle = thread::Builder::new()
            .name("orchestrator".to_string())
            .spawn(move || {
                if let Err(e) = Self::actor_thread_main(term_emulator, args) {
                    error!("OrchestratorActor thread error: {:#}", e);
                }
            })
            .context("Failed to spawn Orchestrator actor thread")?;

        info!("OrchestratorActor spawned successfully");

        Ok(Self {
            thread_handle: Some(thread_handle),
        })
    }

    /// Main loop for the Orchestrator actor thread (priority scheduling model).
    ///
    /// Implements the "Doorbell" model:
    /// 1. Drains the UI queue (high priority).
    /// 2. Processes a limited batch of PTY events (low priority).
    /// 3. Sleeps on the UI queue if both are empty (woken by Doorbell from PTY send).
    fn actor_thread_main(
        mut term_emulator: TerminalEmulator,
        args: OrchestratorArgs,
    ) -> Result<()> {
        let OrchestratorArgs {
            ui_rx,
            pty_rx,
            display_action_tx,
            pty_action_tx,
            waker,
        } = args;

        debug!("OrchestratorActor: Starting event loop (priority channel model)");

        let mut pending_emulator_actions = Vec::new();

        loop {
            // 1. HIGH PRIORITY DRAIN
            // Always empty the UI queue first.
            while let Ok(event) = ui_rx.try_recv() {
                match event {
                    // The doorbell just wakes us; we don't process it as data.
                    OrchestratorEvent::Control(ControlEvent::PtyDataReady) => continue,
                    _ => Self::process_event(
                        event,
                        &mut term_emulator,
                        &mut pending_emulator_actions,
                        &display_action_tx,
                        &waker,
                    )?,
                }
            }

            // 2. LOW PRIORITY BATCH
            // Process a fixed budget of PTY events (e.g., 10 batches)
            // to ensure we yield back to the UI check quickly.
            let mut budget = 10;
            while budget > 0 {
                match pty_rx.try_recv() {
                    Ok(event) => {
                        Self::process_event(
                            event,
                            &mut term_emulator,
                            &mut pending_emulator_actions,
                            &display_action_tx,
                            &waker,
                        )?;
                        budget -= 1;
                    }
                    Err(_) => break, // Empty or Disconnected
                }
            }

            // Handle any pending emulator actions generated by the above processing
            for action in pending_emulator_actions.drain(..) {
                Self::handle_emulator_action(action, &display_action_tx, &pty_action_tx, &waker)?;
            }

            // 3. SMART SLEEP
            // If budget > 0, it means PTY queue was empty (or we drained it).
            // UI queue is also empty (we drained it at step 1).
            // So we can safely sleep on the UI channel.
            //
            // If budget == 0, it means PTY might still have data.
            // We should NOT sleep, but loop back to check UI again (yield).
            if budget > 0 {
                match ui_rx.recv() {
                    Ok(event) => {
                        match event {
                            OrchestratorEvent::Control(ControlEvent::PtyDataReady) => {
                                // Woke up by doorbell, continue to top of loop to process PTY data
                            }
                            _ => {
                                // Process the event that woke us up
                                Self::process_event(
                                    event,
                                    &mut term_emulator,
                                    &mut pending_emulator_actions,
                                    &display_action_tx,
                                    &waker,
                                )?;
                                // Handle actions immediately
                                for action in pending_emulator_actions.drain(..) {
                                    Self::handle_emulator_action(
                                        action,
                                        &display_action_tx,
                                        &pty_action_tx,
                                        &waker,
                                    )?;
                                }
                            }
                        }
                    }
                    Err(RecvError) => {
                        info!("OrchestratorActor: UI channel disconnected, shutting down");
                        return Ok(());
                    }
                }
            }
        }
    }

    /// Process a single event and update state accordingly.
    ///
    /// Handles three event types:
    /// - IOEvent: ANSI commands from PTY
    /// - Control: RequestSnapshot (generates snapshot), FrameRendered (returns snapshot to terminal), Resize
    /// - BackendEvent: User input (keyboard, mouse)
    fn process_event(
        event: OrchestratorEvent,
        term_emulator: &mut TerminalEmulator,
        pending_emulator_actions: &mut Vec<EmulatorAction>,
        display_action_tx: &SyncSender<PlatformAction>,
        waker: &Box<dyn crate::platform::waker::EventLoopWaker>,
    ) -> Result<()> {
        match event {
            OrchestratorEvent::Control(control_event) => {
                match control_event {
                    ControlEvent::RequestSnapshot => {
                        debug!("OrchestratorActor: Received RequestSnapshot");

                        // Ask terminal for its snapshot (it owns the buffer)
                        if let Some(snapshot) = term_emulator.get_render_snapshot() {
                            // Only send snapshot and wake if there are dirty lines (noop detection)
                            let has_dirty_lines = snapshot.lines.iter().any(|line| line.is_dirty);
                            if has_dirty_lines {
                                display_action_tx
                                    .send(PlatformAction::RequestRedraw(Box::new(snapshot)))
                                    .context("Failed to send RequestRedraw to Platform")?;
                                // Wake immediately - we just sent a snapshot to render!
                                if let Err(e) = waker.wake() {
                                    warn!("OrchestratorActor: Failed to wake after sending snapshot: {}", e);
                                }
                            } else {
                                trace!("OrchestratorActor: Snapshot has no dirty lines, skipping render");
                                // Return the clean snapshot immediately
                                term_emulator.return_snapshot(snapshot);
                            }
                        } else {
                            debug!("OrchestratorActor: No snapshot available (synchronized_output or buffer out)");
                        }
                    }
                    ControlEvent::FrameRendered(boxed_snapshot) => {
                        debug!("OrchestratorActor: Received FrameRendered (returning snapshot to terminal)");
                        // Return the snapshot buffer to the terminal
                        term_emulator.return_snapshot(*boxed_snapshot);
                    }
                    ControlEvent::Resize {
                        width_px,
                        height_px,
                        scale_factor,
                    } => {
                        info!(
                            "OrchestratorActor: Resizing to {}x{} px (scale={})",
                            width_px, height_px, scale_factor
                        );
                        if let Some(action) = term_emulator.interpret_input(EmulatorInput::Control(
                            ControlEvent::Resize {
                                width_px,
                                height_px,
                                scale_factor,
                            },
                        )) {
                            pending_emulator_actions.push(action);
                        }
                    }
                    ControlEvent::PtyDataReady => {
                        // Should be handled by the loop logic (doorbell), but if it slips through:
                        trace!("OrchestratorActor: Received PtyDataReady in process_event (noop)");
                    }
                }
            }
            OrchestratorEvent::IOEvent {
                commands: ansi_commands,
            } => {
                debug!(
                    "OrchestratorActor: Received {} ANSI commands from PTY",
                    ansi_commands.len()
                );

                for command in ansi_commands {
                    if let Some(action) =
                        term_emulator.interpret_input(EmulatorInput::Ansi(command))
                    {
                        pending_emulator_actions.push(action);
                    }
                }
            }
            OrchestratorEvent::BackendEvent(backend_event) => {
                debug!(
                    "OrchestratorActor: Received BackendEvent: {:?}",
                    backend_event
                );

                if let BackendEvent::CloseRequested = backend_event {
                    info!("OrchestratorActor: CloseRequested received - sending ShutdownComplete and exiting");
                    display_action_tx
                        .send(PlatformAction::ShutdownComplete)
                        .context("Failed to send ShutdownComplete to Platform")?;
                    // Wake immediately so platform processes shutdown
                    if let Err(e) = waker.wake() {
                        warn!("Failed to wake for shutdown: {}", e);
                    }
                    return Err(anyhow::anyhow!("CloseRequested - shutting down"));
                }

                let emulator_input = Self::process_backend_event(backend_event, term_emulator)?;

                if let Some(input) = emulator_input {
                    if let Some(action) = term_emulator.interpret_input(input) {
                        pending_emulator_actions.push(action);
                    }
                }
            }
        }
        Ok(())
    }

    /// Process a BackendEvent and return the corresponding EmulatorInput.
    fn process_backend_event(
        backend_event: BackendEvent,
        _term_emulator: &mut TerminalEmulator,
    ) -> Result<Option<EmulatorInput>> {
        match backend_event {
            BackendEvent::CloseRequested => {
                warn!("OrchestratorActor: CloseRequested reached process_backend_event (should not happen)");
                Ok(None)
            }
            BackendEvent::Resize {
                width_px,
                height_px,
                scale_factor,
            } => {
                // Forward physical dimensions to emulator, which will calculate cols/rows
                info!(
                    "OrchestratorActor: Forwarding resize {}x{} px (scale={}) to emulator",
                    width_px, height_px, scale_factor
                );

                Ok(Some(EmulatorInput::Control(ControlEvent::Resize {
                    width_px,
                    height_px,
                    scale_factor,
                })))
            }
            BackendEvent::Key {
                symbol,
                modifiers,
                text,
            } => {
                debug!(
                    "OrchestratorActor: Key: {:?} + {:?}, Text: {:?}",
                    modifiers, symbol, text
                );
                let key_input_action =
                    keys::map_key_event_to_action(symbol, modifiers, &crate::config::CONFIG)
                        .unwrap_or(UserInputAction::KeyInput {
                            symbol,
                            modifiers,
                            text: if text.is_empty() { None } else { Some(text) },
                        });
                Ok(Some(EmulatorInput::User(key_input_action)))
            }
            BackendEvent::MouseButtonPress {
                button,
                x,
                y,
                scale_factor,
                modifiers: _,
            } => {
                let input = match button {
                    MouseButton::Left => {
                        // Forward pixel coordinates to emulator, which will convert to cells
                        Some(EmulatorInput::User(UserInputAction::StartSelection {
                            x_px: x,
                            y_px: y,
                            scale_factor,
                        }))
                    }
                    MouseButton::Middle => {
                        Some(EmulatorInput::User(UserInputAction::RequestPrimaryPaste))
                    }
                    _ => None,
                };
                Ok(input)
            }
            BackendEvent::MouseButtonRelease {
                button,
                x: _x,
                y: _y,
                scale_factor: _scale_factor,
                modifiers: _,
            } => {
                if button == MouseButton::Left {
                    Ok(Some(EmulatorInput::User(
                        UserInputAction::ApplySelectionClear,
                    )))
                } else {
                    Ok(None)
                }
            }
            BackendEvent::MouseMove {
                x,
                y,
                scale_factor,
                modifiers: _,
            } => {
                // Forward pixel coordinates to emulator, which will convert to cells
                Ok(Some(EmulatorInput::User(
                    UserInputAction::ExtendSelection {
                        x_px: x,
                        y_px: y,
                        scale_factor,
                    },
                )))
            }
            BackendEvent::FocusGained => {
                Ok(Some(EmulatorInput::User(UserInputAction::FocusGained)))
            }
            BackendEvent::FocusLost => Ok(Some(EmulatorInput::User(UserInputAction::FocusLost))),
            BackendEvent::PasteData { text } => {
                Ok(Some(EmulatorInput::User(UserInputAction::PasteText(text))))
            }
            BackendEvent::ClipboardDataRequested => {
                // X11 clipboard protocol: another app is requesting our clipboard data
                // TODO: Send current clipboard text to display via SubmitClipboardData
                // For now, just ignore this event - clipboard won't work properly on X11
                warn!("ClipboardDataRequested: clipboard support not yet implemented");
                Ok(None)
            }
        }
    }

    /// Handle an EmulatorAction by sending it to the appropriate actor.
    fn handle_emulator_action(
        action: EmulatorAction,
        display_tx: &SyncSender<PlatformAction>,
        pty_tx: &SyncSender<PlatformAction>,
        waker: &Box<dyn crate::platform::waker::EventLoopWaker>,
    ) -> Result<()> {
        debug!("OrchestratorActor: Handling EmulatorAction: {:?}", action);

        match action {
            EmulatorAction::WritePty(data) => {
                pty_tx
                    .send(PlatformAction::Write(data))
                    .context("Failed to send Write to PTY")?;
            }
            EmulatorAction::SetTitle(title) => {
                display_tx
                    .send(PlatformAction::SetTitle(title))
                    .context("Failed to send SetTitle to Display")?;
                // Wake - window title changed
                if let Err(e) = waker.wake() {
                    warn!("Failed to wake after SetTitle: {}", e);
                }
            }
            EmulatorAction::RingBell => {
                display_tx
                    .send(PlatformAction::RingBell)
                    .context("Failed to send RingBell to Display")?;
                // Wake - bell needs immediate feedback
                if let Err(e) = waker.wake() {
                    warn!("Failed to wake after RingBell: {}", e);
                }
            }
            EmulatorAction::CopyToClipboard(text) => {
                display_tx
                    .send(PlatformAction::CopyToClipboard(text))
                    .context("Failed to send CopyToClipboard to Display")?;
                // Wake - user expects clipboard to be updated immediately
                if let Err(e) = waker.wake() {
                    warn!("Failed to wake after CopyToClipboard: {}", e);
                }
            }
            EmulatorAction::SetCursorVisibility(visible) => {
                display_tx
                    .send(PlatformAction::SetCursorVisibility(visible))
                    .context("Failed to send SetCursorVisibility to Display")?;
                // Wake - cursor visibility is a visual change
                if let Err(e) = waker.wake() {
                    warn!("Failed to wake after SetCursorVisibility: {}", e);
                }
            }
            EmulatorAction::RequestRedraw => {
                trace!("OrchestratorActor: RequestRedraw received (no-op in actor model)");
            }
            EmulatorAction::RequestClipboardContent => {
                display_tx
                    .send(PlatformAction::RequestPaste)
                    .context("Failed to send RequestPaste to Display")?;
                // Wake - need to process paste request
                if let Err(e) = waker.wake() {
                    warn!("Failed to wake after RequestPaste: {}", e);
                }
            }
            EmulatorAction::ResizePty { cols, rows } => {
                info!("OrchestratorActor: Resizing PTY to {}x{}", cols, rows);
                pty_tx
                    .send(PlatformAction::ResizePty { cols, rows })
                    .context("Failed to send ResizePty to PTY")?;
                // No wake - PTY resize doesn't affect display immediately
            }
        }
        Ok(())
    }
}

impl Drop for OrchestratorActor {
    fn drop(&mut self) {
        debug!("OrchestratorActor dropped");
        if let Some(handle) = self.thread_handle.take() {
            if let Err(e) = handle.join() {
                error!("OrchestratorActor thread panicked: {:?}", e);
            }
        }
    }
}
