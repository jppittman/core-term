//! Cost model builder using learned weights.
//!
//! Loads learned operation costs from `pixelflow-ml/data/learned_cost_model.toml`,
//! which are trained from real SIMD benchmark measurements on target hardware.
//!
//! ## No Dependency Cycle
//!
//! The *code* can't depend on pixelflow-ml (would create a cycle), but the *data*
//! is just a TOML file embedded at compile time. Train on any platform, compile anywhere.

use pixelflow_ir::OpKind;
use pixelflow_search::egraph::CostModel;

/// Learned cost model weights, embedded at compile time.
///
/// This file is generated by `pixelflow-ml` training:
/// ```bash
/// cargo run -p pixelflow-ml --example train_cost_model --features training --release
/// ```
static LEARNED_WEIGHTS_TOML: &str = include_str!("../data/learned_cost_model.toml");

/// Build a cost model from learned weights embedded at compile time.
///
/// Falls back to sensible defaults if parsing fails.
pub fn build_cost_model_with_hce() -> CostModel {
    parse_cost_model_toml(LEARNED_WEIGHTS_TOML)
}

/// Parse a cost model from TOML string.
fn parse_cost_model_toml(toml: &str) -> CostModel {
    let mut model = CostModel::default();

    for line in toml.lines() {
        let line = line.trim();
        if line.is_empty() || line.starts_with('#') {
            continue;
        }

        if let Some((key, value)) = line.split_once('=') {
            let key = key.trim();
            let value = value.trim();
            if let Ok(v) = value.parse::<usize>() {
                if key == "depth_threshold" {
                    model.depth_threshold = v;
                } else if key == "depth_penalty" {
                    model.depth_penalty = v;
                } else {
                    // Try to match OpKind by name
                    for i in 0..OpKind::COUNT {
                        if let Some(op) = OpKind::from_index(i) {
                            if op.name() == key {
                                model.set_cost(op, v);
                                break;
                            }
                        }
                    }
                }
            }
        }
    }

    model
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_load_learned_weights() {
        let model = build_cost_model_with_hce();

        // Sanity checks: expensive ops should cost more than cheap ones
        assert!(
            model.cost(OpKind::Div) > model.cost(OpKind::Add),
            "Division should be more expensive than addition"
        );
        assert!(
            model.cost(OpKind::Sqrt) > model.cost(OpKind::Neg),
            "Sqrt should be more expensive than negation"
        );
    }

    #[test]
    fn test_parse_toml() {
        let toml = r#"
            # Comment
            add = 10
            mul = 20
            depth_threshold = 16
        "#;

        let model = parse_cost_model_toml(toml);
        assert_eq!(model.cost(OpKind::Add), 10);
        assert_eq!(model.cost(OpKind::Mul), 20);
        assert_eq!(model.depth_threshold, 16);
    }
}
