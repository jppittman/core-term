//! Cost Model Weight Training via Benchmark Feedback
//!
//! This example demonstrates the full training loop:
//! 1. Generate random expressions using backward generation
//! 2. Add to e-graph and saturate with algebraic rules
//! 3. Extract variants with different cost models
//! 4. Generate kernel! benchmark code
//! 5. Parse benchmark results and update weights
//!
//! Run with: cargo run -p pixelflow-search --example train_cost_weights
//!
//! For the full pipeline:
//! 1. Generate benchmarks: cargo run -p pixelflow-search --example train_cost_weights > benchmarks.rs
//! 2. Run benchmarks: cargo bench -p pixelflow-ml --bench generated_kernels --features no_optimize
//! 3. Collect costs and update weights

use pixelflow_nnue::{BwdGenConfig, BwdGenerator, Expr, OpType};
use pixelflow_search::egraph::{CostModel, EGraph, ENode, EClassId};

fn main() {
    println!("//! Auto-generated cost model training benchmarks");
    println!("//!");
    println!("//! Generated by: cargo run -p pixelflow-search --example train_cost_weights");
    println!();
    println!("use criterion::{{Criterion, black_box, criterion_group, criterion_main}};");
    println!("use pixelflow_core::{{Field, Manifold}};");
    println!("use pixelflow_macros::kernel;");
    println!();
    println!("fn bench_cost_training(c: &mut Criterion) {{");
    println!("    let mut group = c.benchmark_group(\"cost_training\");");
    println!("    group.sample_size(100);");
    println!();
    println!("    let xf = Field::sequential(1.0);");
    println!("    let yf = Field::from(2.0);");
    println!("    let zf = Field::from(3.0);");
    println!("    let wf = Field::from(0.5);");
    println!();

    // Generate training pairs using backward generation
    let config = BwdGenConfig {
        max_depth: 4,
        leaf_prob: 0.3,
        num_vars: 4,
        fused_op_prob: 0.5,
        max_unfuse_passes: 2,
        unfuse_prob: 0.6,
    };
    let mut generator = BwdGenerator::new(42, config);

    let mut pair_count = 0;
    let max_pairs = 10;

    // Generate pairs via BWD and then run through e-graph
    for i in 0..100 {
        if pair_count >= max_pairs {
            break;
        }

        let pair = generator.generate();

        // Skip trivial expressions
        if pair.optimized.node_count() < 3 {
            continue;
        }

        // Add to e-graph and get optimal form
        let mut eg = EGraph::new();
        let root = expr_to_egraph(&pair.unoptimized, &mut eg);
        eg.saturate();

        let costs = CostModel::fully_optimized();
        let egraph_opt = eg.extract_tree_with_costs(root, &costs);

        // Generate kernel code for both forms
        let unopt_kernel = expr_to_kernel(&pair.unoptimized);
        let egraph_kernel = expr_tree_to_kernel(&egraph_opt);

        // Output benchmarks
        println!("    // pair{:04} - unoptimized ({} nodes) vs egraph-optimized ({} nodes)",
            i, pair.unoptimized.node_count(), egraph_opt.node_count());
        println!("    {{");
        println!("        let k = kernel!(|| {});", unopt_kernel);
        println!("        let m = k();");
        println!("        group.bench_function(\"pair{:04}_unopt\", |b| {{", i);
        println!("            b.iter(|| black_box(m.eval((black_box(xf), black_box(yf), black_box(zf), black_box(wf)))))");
        println!("        }});");
        println!("    }}");
        println!();
        println!("    {{");
        println!("        let k = kernel!(|| {});", egraph_kernel);
        println!("        let m = k();");
        println!("        group.bench_function(\"pair{:04}_opt\", |b| {{", i);
        println!("            b.iter(|| black_box(m.eval((black_box(xf), black_box(yf), black_box(zf), black_box(wf)))))");
        println!("        }});");
        println!("    }}");
        println!();

        pair_count += 1;
    }

    println!("    group.finish();");
    println!("}}");
    println!();
    println!("criterion_group!(");
    println!("    name = cost_training;");
    println!("    config = Criterion::default().sample_size(100);");
    println!("    targets = bench_cost_training,");
    println!(");");
    println!();
    println!("criterion_main!(cost_training);");

    // Also output the current cost model weights for reference
    eprintln!("\n=== Current CostModel Weights ===");
    let cm = CostModel::fully_optimized();
    eprintln!("add: {}", cm.add);
    eprintln!("sub: {}", cm.sub);
    eprintln!("mul: {}", cm.mul);
    eprintln!("div: {}", cm.div);
    eprintln!("neg: {}", cm.neg);
    eprintln!("sqrt: {}", cm.sqrt);
    eprintln!("recip: {}", cm.recip);
    eprintln!("rsqrt: {}", cm.rsqrt);
    eprintln!("abs: {}", cm.abs);
    eprintln!("min: {}", cm.min);
    eprintln!("max: {}", cm.max);
    eprintln!("mul_add: {}", cm.mul_add);
    eprintln!("\n=== Training Complete ===");
}

/// Convert pixelflow_nnue::Expr to e-graph EClassId
fn expr_to_egraph(expr: &Expr, eg: &mut EGraph) -> EClassId {
    match expr {
        Expr::Var(i) => eg.add(ENode::Var(*i)),
        Expr::Const(c) => eg.add(ENode::constant(*c)),
        Expr::Binary(op, a, b) => {
            let a_id = expr_to_egraph(a, eg);
            let b_id = expr_to_egraph(b, eg);
            let node = match op {
                OpType::Add => ENode::Add(a_id, b_id),
                OpType::Sub => ENode::Sub(a_id, b_id),
                OpType::Mul => ENode::Mul(a_id, b_id),
                OpType::Div => ENode::Div(a_id, b_id),
                OpType::Min => ENode::Min(a_id, b_id),
                OpType::Max => ENode::Max(a_id, b_id),
                OpType::MulRsqrt => {
                    // MulRsqrt(x, y) = x * rsqrt(y)
                    let rsqrt = eg.add(ENode::Rsqrt(b_id));
                    ENode::Mul(a_id, rsqrt)
                }
                _ => panic!("Unsupported binary op: {:?}", op),
            };
            eg.add(node)
        }
        Expr::Unary(op, a) => {
            let a_id = expr_to_egraph(a, eg);
            let node = match op {
                OpType::Neg => ENode::Neg(a_id),
                OpType::Sqrt => ENode::Sqrt(a_id),
                OpType::Rsqrt => ENode::Rsqrt(a_id),
                OpType::Abs => ENode::Abs(a_id),
                _ => panic!("Unsupported unary op: {:?}", op),
            };
            eg.add(node)
        }
        Expr::Ternary(op, a, b, c) => {
            let a_id = expr_to_egraph(a, eg);
            let b_id = expr_to_egraph(b, eg);
            let c_id = expr_to_egraph(c, eg);
            let node = match op {
                OpType::MulAdd => ENode::MulAdd(a_id, b_id, c_id),
                _ => panic!("Unsupported ternary op: {:?}", op),
            };
            eg.add(node)
        }
    }
}

/// Convert pixelflow_nnue::Expr to kernel! macro syntax
fn expr_to_kernel(expr: &Expr) -> String {
    match expr {
        Expr::Var(i) => match i {
            0 => "X".to_string(),
            1 => "Y".to_string(),
            2 => "Z".to_string(),
            3 => "W".to_string(),
            _ => format!("var{}", i),
        },
        Expr::Const(c) => {
            if *c >= 0.0 {
                format!("({:.6})", c)
            } else {
                format!("({:.6})", c)
            }
        }
        Expr::Binary(op, a, b) => {
            let a_str = expr_to_kernel(a);
            let b_str = expr_to_kernel(b);
            match op {
                OpType::Add => format!("({} + {})", a_str, b_str),
                OpType::Sub => format!("({} - {})", a_str, b_str),
                OpType::Mul => format!("({} * {})", a_str, b_str),
                OpType::Div => format!("({} / {})", a_str, b_str),
                OpType::Min => format!("({}).min({})", a_str, b_str),
                OpType::Max => format!("({}).max({})", a_str, b_str),
                OpType::MulRsqrt => format!("({} * ({}).rsqrt())", a_str, b_str),
                _ => format!("unsupported_binary({}, {})", a_str, b_str),
            }
        }
        Expr::Unary(op, a) => {
            let a_str = expr_to_kernel(a);
            match op {
                OpType::Neg => format!("(-{})", a_str),
                OpType::Sqrt => format!("({}).sqrt()", a_str),
                OpType::Rsqrt => format!("({}).rsqrt()", a_str),
                OpType::Abs => format!("({}).abs()", a_str),
                _ => format!("unsupported_unary({})", a_str),
            }
        }
        Expr::Ternary(op, a, b, c) => {
            let a_str = expr_to_kernel(a);
            let b_str = expr_to_kernel(b);
            let c_str = expr_to_kernel(c);
            match op {
                OpType::MulAdd => format!("({}).mul_add({}, {})", a_str, b_str, c_str),
                _ => format!("unsupported_ternary({}, {}, {})", a_str, b_str, c_str),
            }
        }
    }
}

/// Convert ExprTree to kernel! macro syntax
fn expr_tree_to_kernel(tree: &pixelflow_search::egraph::ExprTree) -> String {
    use pixelflow_search::egraph::ExprTree;

    match tree {
        ExprTree::Var(i) => match i {
            0 => "X".to_string(),
            1 => "Y".to_string(),
            2 => "Z".to_string(),
            3 => "W".to_string(),
            _ => format!("var{}", i),
        },
        ExprTree::Const(c) => format!("({:.6})", c),
        ExprTree::Add(a, b) => format!("({} + {})", expr_tree_to_kernel(a), expr_tree_to_kernel(b)),
        ExprTree::Sub(a, b) => format!("({} - {})", expr_tree_to_kernel(a), expr_tree_to_kernel(b)),
        ExprTree::Mul(a, b) => format!("({} * {})", expr_tree_to_kernel(a), expr_tree_to_kernel(b)),
        ExprTree::Div(a, b) => format!("({} / {})", expr_tree_to_kernel(a), expr_tree_to_kernel(b)),
        ExprTree::Neg(a) => format!("(-{})", expr_tree_to_kernel(a)),
        ExprTree::Recip(a) => format!("({}).recip()", expr_tree_to_kernel(a)),
        ExprTree::Sqrt(a) => format!("({}).sqrt()", expr_tree_to_kernel(a)),
        ExprTree::Rsqrt(a) => format!("({}).rsqrt()", expr_tree_to_kernel(a)),
        ExprTree::Abs(a) => format!("({}).abs()", expr_tree_to_kernel(a)),
        ExprTree::Min(a, b) => format!("({}).min({})", expr_tree_to_kernel(a), expr_tree_to_kernel(b)),
        ExprTree::Max(a, b) => format!("({}).max({})", expr_tree_to_kernel(a), expr_tree_to_kernel(b)),
        ExprTree::MulAdd(a, b, c) => format!(
            "({}).mul_add({}, {})",
            expr_tree_to_kernel(a),
            expr_tree_to_kernel(b),
            expr_tree_to_kernel(c)
        ),
        _ => "unsupported_tree".to_string(),
    }
}
