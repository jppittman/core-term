// build.rs - Pre-bake Noto Sans Mono font at build time

fn main() {
    println!(
        "cargo:rerun-if-changed=../assets/font/Noto_Sans_Mono/static/NotoSansMono-Regular.ttf"
    );

    // Only run font baking when fonts feature is enabled
    #[cfg(feature = "fonts")]
    bake_font();
}

#[cfg(feature = "fonts")]
fn bake_font() {
    use fontdue::{Font, FontSettings};
    use std::fs;

    println!("cargo:warning=Pre-baking Noto Sans Mono font...");

    // Load the font file
    let font_path = "../assets/font/Noto_Sans_Mono/static/NotoSansMono-Regular.ttf";
    let font_data = fs::read(font_path).expect("Failed to read NotoSansMono-Regular.ttf");

    let font = Font::from_bytes(font_data.as_slice(), FontSettings::default())
        .expect("Failed to parse NotoSansMono-Regular.ttf");

    // Characters to bake - we'll bake all characters that Noto Sans Mono supports
    // Based on fc-query output, this is 3,488 glyphs across multiple Unicode blocks
    let char_ranges = get_noto_sans_mono_char_ranges();

    let font_size_px = 24.0;

    let mut all_glyph_data = Vec::new();
    let mut glyph_metadata = Vec::new();

    let mut total_chars = 0;

    for (start, end) in char_ranges {
        for codepoint in start..=end {
            if let Some(c) = char::from_u32(codepoint) {
                // Rasterize the character
                let (metrics, bitmap) = font.rasterize(c, font_size_px);

                // Skip empty glyphs
                if metrics.width == 0 || metrics.height == 0 {
                    continue;
                }

                // Pack to 4-bit
                let packed = pack_4bit(&bitmap);

                // Record metadata
                let offset = all_glyph_data.len();
                glyph_metadata.push(GlyphMeta {
                    c,
                    offset,
                    width: metrics.width,
                    height: metrics.height,
                    bearing_x: metrics.xmin,
                    bearing_y: metrics.ymin,
                    advance: metrics.advance_width,
                });

                // Append packed data
                all_glyph_data.extend(packed);
                total_chars += 1;
            }
        }
    }

    println!(
        "cargo:warning=Pre-baked {} glyphs, total size: {} bytes",
        total_chars,
        all_glyph_data.len()
    );

    // Generate Rust code
    generate_baked_font_code(&all_glyph_data, &glyph_metadata, font_size_px);
}

#[cfg(feature = "fonts")]
struct GlyphMeta {
    c: char,
    offset: usize,
    width: usize,
    height: usize,
    bearing_x: i32,
    bearing_y: i32,
    advance: f32,
}

#[cfg(feature = "fonts")]
fn pack_4bit(bitmap: &[u8]) -> Vec<u8> {
    let mut packed = Vec::with_capacity((bitmap.len() + 1) / 2);
    let mut high_nibble = true;
    let mut current_byte = 0u8;

    for &pixel in bitmap {
        // Quantize 0..255 -> 0..15
        let val_4bit = ((pixel as u16 + 8) / 17).min(15) as u8;

        if high_nibble {
            current_byte = val_4bit << 4;
            high_nibble = false;
        } else {
            current_byte |= val_4bit;
            packed.push(current_byte);
            high_nibble = true;
        }
    }

    // Push final byte if we ended on a high nibble
    if !high_nibble {
        packed.push(current_byte);
    }

    packed
}

#[cfg(feature = "fonts")]
fn generate_baked_font_code(glyph_data: &[u8], metadata: &[GlyphMeta], font_size_px: f32) {
    use std::{env, fs, path::Path};

    let out_dir = env::var("OUT_DIR").unwrap();
    let dest_path = Path::new(&out_dir).join("baked_font.rs");

    let mut code = String::new();

    // Write constants
    code.push_str(&format!("// Auto-generated by build.rs - DO NOT EDIT\n\n"));
    code.push_str(&format!(
        "pub const FONT_SIZE_PT: f64 = {:.1};\n\n",
        font_size_px
    ));

    // Write glyph data
    code.push_str("pub static GLYPH_DATA: &[u8] = &[\n");
    for chunk in glyph_data.chunks(16) {
        code.push_str("    ");
        for byte in chunk {
            code.push_str(&format!("0x{:02x}, ", byte));
        }
        code.push_str("\n");
    }
    code.push_str("];\n\n");

    // Write glyph metadata structure
    code.push_str("#[derive(Debug, Clone, Copy)]\n");
    code.push_str("pub struct GlyphMeta {\n");
    code.push_str("    pub c: char,\n");
    code.push_str("    pub offset: usize,\n");
    code.push_str("    pub width: usize,\n");
    code.push_str("    pub height: usize,\n");
    code.push_str("    pub bearing_x: i32,\n");
    code.push_str("    pub bearing_y: i32,\n");
    code.push_str("    pub advance: f32,\n");
    code.push_str("}\n\n");

    // Write glyph metadata array
    code.push_str("pub static GLYPH_METADATA: &[GlyphMeta] = &[\n");
    for meta in metadata {
        code.push_str(&format!(
            "    GlyphMeta {{ c: '{}', offset: {}, width: {}, height: {}, bearing_x: {}, bearing_y: {}, advance: {:.2} }},\n",
            escape_char(meta.c),
            meta.offset,
            meta.width,
            meta.height,
            meta.bearing_x,
            meta.bearing_y,
            meta.advance
        ));
    }
    code.push_str("];\n");

    fs::write(&dest_path, code).unwrap();
}

#[cfg(feature = "fonts")]
fn escape_char(c: char) -> String {
    match c {
        '\'' => "\\'".to_string(),
        '\\' => "\\\\".to_string(),
        '\n' => "\\n".to_string(),
        '\r' => "\\r".to_string(),
        '\t' => "\\t".to_string(),
        '\0' => "\\0".to_string(),
        _ if c.is_control() => format!("\\u{{{:04x}}}", c as u32),
        _ => c.to_string(),
    }
}

#[cfg(feature = "fonts")]
fn get_noto_sans_mono_char_ranges() -> Vec<(u32, u32)> {
    // Character ranges from fc-query output for NotoSansMono-Regular.ttf
    // This represents all 3,488 glyphs in the font
    vec![
        (0x0020, 0x007e), // Basic Latin
        (0x00a0, 0x00ac),
        (0x00ae, 0x0377),
        (0x037a, 0x037f),
        (0x0384, 0x038a),
        (0x038c, 0x038c),
        (0x038e, 0x03a1),
        (0x03a3, 0x03e1),
        (0x03f0, 0x052f),
        (0x10fb, 0x10fb),
        (0x1ab0, 0x1ac0),
        (0x1ac5, 0x1ac5),
        (0x1ac7, 0x1ace),
        (0x1c80, 0x1c88),
        (0x1d00, 0x1df9),
        (0x1dfb, 0x1f15),
        (0x1f18, 0x1f1d),
        (0x1f20, 0x1f45),
        (0x1f48, 0x1f4d),
        (0x1f50, 0x1f57),
        (0x1f59, 0x1f59),
        (0x1f5b, 0x1f5b),
        (0x1f5d, 0x1f5d),
        (0x1f5f, 0x1f7d),
        (0x1f80, 0x1fb4),
        (0x1fb6, 0x1fc4),
        (0x1fc6, 0x1fd3),
        (0x1fd6, 0x1fdb),
        (0x1fdd, 0x1fef),
        (0x1ff2, 0x1ff4),
        (0x1ff6, 0x1ffe),
        (0x2000, 0x2064),
        (0x2066, 0x2071),
        (0x2074, 0x208e),
        (0x2090, 0x209c),
        (0x20a0, 0x20c0),
        (0x20f0, 0x20f0),
        (0x2100, 0x215f),
        (0x2183, 0x2184),
        (0x2189, 0x2189),
        (0x2190, 0x2195),
        (0x219c, 0x219e),
        (0x21a0, 0x21a0),
        (0x21a2, 0x21a4),
        (0x21a6, 0x21a6),
        (0x21d0, 0x21d4),
        (0x21da, 0x21db),
        (0x21e6, 0x21e6),
        (0x21e8, 0x21e8),
        (0x2200, 0x220e),
        (0x2210, 0x2210),
        (0x2212, 0x2212),
        (0x2218, 0x221a),
        (0x221e, 0x221e),
        (0x2220, 0x2220),
        (0x2223, 0x2223),
        (0x2227, 0x222a),
        (0x2234, 0x2238),
        (0x223c, 0x223d),
        (0x2241, 0x2241),
        (0x2243, 0x2243),
        (0x2245, 0x2245),
        (0x2247, 0x224c),
        (0x2254, 0x2255),
        (0x2257, 0x2257),
        (0x225f, 0x2262),
        (0x2264, 0x2265),
        (0x226c, 0x226c),
        (0x226e, 0x2275),
        (0x227a, 0x227b),
        (0x2282, 0x2289),
        (0x228e, 0x228e),
        (0x2291, 0x229c),
        (0x22a2, 0x22a5),
        (0x22b4, 0x22b5),
        (0x22b8, 0x22b8),
        (0x22c2, 0x22c4),
        (0x22c6, 0x22c6),
        (0x22c8, 0x22ca),
        (0x22cd, 0x22ce),
        (0x22d0, 0x22d1),
        (0x22e2, 0x22e3),
        (0x2308, 0x230b),
        (0x2310, 0x2310),
        (0x2319, 0x2319),
        (0x2320, 0x2321),
        (0x2336, 0x237a),
        (0x2395, 0x2395),
        (0x239b, 0x23ae),
        (0x23b0, 0x23bd),
        (0x23dc, 0x23e1),
        (0x2474, 0x2475),
        (0x2500, 0x25ff), // Box Drawing & Block Elements (critical for TUIs)
        (0x266d, 0x266f),
        (0x2736, 0x2736),
        (0x2758, 0x275a),
        (0x27d5, 0x27d7),
        (0x27dc, 0x27dc),
        (0x27e6, 0x27eb),
        (0x27f5, 0x27f6),
        (0x2987, 0x2988),
        (0x29a3, 0x29a3),
        (0x29b8, 0x29b8),
        (0x2a00, 0x2a00),
        (0x2a05, 0x2a06),
        (0x2c60, 0x2c7f),
        (0x2de0, 0x2e5d),
        (0xa640, 0xa69f),
        (0xa700, 0xa7ca),
        (0xa7d0, 0xa7d1),
        (0xa7d3, 0xa7d3),
        (0xa7d5, 0xa7d9),
        (0xa7f2, 0xa7ff),
        (0xa92e, 0xa92e),
        (0xab30, 0xab6b),
        (0xfe00, 0xfe00),
        (0xfe20, 0xfe2f),
        (0xfeff, 0xfeff),
        (0xff5b, 0xff5b),
        (0xff5d, 0xff5d),
        (0xfffc, 0xfffd),
        (0x10780, 0x10785),
        (0x10787, 0x107b0),
        (0x107b2, 0x107ba),
        (0x1df00, 0x1df1e),
        (0x1f67c, 0x1f67f),
    ]
}
